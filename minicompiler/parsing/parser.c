#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include "lexer.h"
#include "keyword_table.h"
#include "symbol_table.h"
#include "parser.h"
#include "table_generator.h"
#include "type_checker.h"
#include "consts.h"
#include "treedrawer.h"

/*
 * The following file implements an LR parser and constructs an abstract
 * syntax tree (AST). The implementation of AST construction follows the
 * scheme described in the Dragon book for postfix SDT's.
 * Disclaimer: while some error repairing techniques are implemented, this is
 * a work in progress.
 */

#define STACK_SIZE 8192
#define DEBUG 0
#define TREEBUILDER 1
#define TREEDRAWER 1
#define LABELS 0

char grammar_error = FALSE;
char recovery_mode = FALSE;

/*
 * Since nested function declaration and return statement not within function
 * bodies are allowed by the grammar according to the grammar, enforcing these
 * rules are handled by the following variables which are set during parsing
 * according to context.
 * Note: while enforcing this in the grammar would be possible, this requieres
 * duplication of several productions resulting in a bigger parsing table and
 * thus a waste of resources.

 * NOTE: This will be deprecated and replaced by actions during  treewalk of
 * semantic analysis.
 */
char return_found = FALSE;
struct Line return_line;
int return_line_num;
int return_col_num;
char func_decl_found = FALSE;

struct CompStmt* lr_parser(char verbose, char* basename)
/*
 * Pushdown automaton for LR parsing. Uses a LALR parsing table and generated by
 * "table_generator.c", and produces a parse of the token stream from the lexer.
 */
{

    #if DEBUG
    printf("parsing...\n");
    #endif
    void* tree_stack[STACK_SIZE];
    void** record_ptr = tree_stack;
    int stack[STACK_SIZE];
    int* s_ptr = stack;
    struct Token* a = get_token();
    enum TokenType type = a->type;
    struct Token* recovery_token = NULL;
    *s_ptr = 0;
    *record_ptr = NULL;

    int action;
    parsing_loop:
    while (TRUE) {
        action = action_table[*s_ptr][type];

        #if DEBUG
        printf("Stack depth %ld, top: %d\n", s_ptr-stack, *s_ptr);
        printf("action %d lexeme: ", action);
        print_token_str(a);
        printf(", %x\n", type);
        #endif

        if (action >= n_states) {
            printf("error in state %d on input ", *s_ptr);
            if (type == 0x04)
                printf("'EOF'\n");
            else
                print_token_str(a);
            printf("\n");
            #if DEBUG
            printf("Stack: ");
            for (int i = 0; i <=  s_ptr-stack; i++)
                printf("%d, ", *(stack+i));
            printf("\n");
            #endif
            int* row = action_table[*s_ptr];
            int len;
            if (type < 128) {
                len = 1;
            }
            else if (type == ICONST || type == FCONST) {
                int_error(a, type);
                goto cleanup;
            }
            else {
                len = strlen(a->lexeme);
            }
            if ((recovery_token = insertion_fix(row, len, &a, &type)) != NULL)
                goto parsing_loop;

            generic_error(a, len);
            cleanup:
            free_token(a);

            return NULL;

        } else if (action >= 0) {
            s_ptr++;
            #if DEBUG
            printf("Push %d\n", action);
            #endif
            *s_ptr = action;
            record_ptr++;
            create_token_record(&record_ptr, a);
            if (recovery_mode) {
                #if DEBUG
                printf("IN RECORVERY\n");
                #endif
                a = recovery_token;
                type = a->type;
                recovery_mode = FALSE;
            } else {
                a = get_token();
                type = a->type;
                if (type == RETURN) {
                    copy_current_line(&return_line);
                    return_col_num = a->column;
                }
            }

        } else if (action == -1) {
            free(a); // struct Token* a is necessarily eof, therefore no lexeme
            #if TREEDRAWER
            treedrawer_init(basename, *record_ptr);
            #endif
            return (struct CompStmt*)(*record_ptr);

        } else {
            /*
             * Reduction rules are stored in the negative half of the
             * numberline, hence:
             */
            action = -(action+1);
            enum NodeType r = reduction_rules[action];

            int n_pop = n_pop_states[action];
            s_ptr -= n_pop;
            int tmp = *s_ptr;
            s_ptr++;
            *s_ptr = goto_table[r][tmp];
            #if DEBUG
            printf("r num %d\n", action);
            #endif
            create_node_record(&record_ptr, action);
            #if DEBUG
            printf("reduce by %s\n", rules[action]);
            #endif
        }
    }
}

void parser_error(int length, const char* expected,
          int fatal, int line, int column,
          int inject_symbol, char symbol)
{
    /*
     * Error interface for parser.
     */
    error("syntax error", length, expected, fatal, line, column,
        inject_symbol, symbol);
}

struct Token* insertion_fix(int* action_row, int len,
                            struct Token** a_ptr, enum TokenType* type_ptr)
{
    char msg[20+len+3];
    char anker_symbols[] = {';', '}'};
    for (char i = 0; i < 2; i++) {
        char symbol = anker_symbols[i];
        if (action_row[symbol] < n_states) {
            strcpy(msg, "Expected ");
            strncat(msg, &symbol, 1);
            strcat(msg, " before '");
            if ((*type_ptr) == 0x04)
                strcat(msg, "eof");
            else if ((*type_ptr) < 128)
                strncat(msg, &((*a_ptr)->c_val), 1);
            else
                strcat(msg, (*a_ptr)->lexeme);
            strcat(msg, "'");
            struct Token* tmp = inject_token(symbol);
            parser_error(len, msg, 0, (*a_ptr)->line, (*a_ptr)->column, 2*i-1, symbol);
            grammar_error = TRUE;
            struct Token* recovery_token = (*a_ptr);
            (*a_ptr) = tmp;
            (*type_ptr) = tmp->type;
            recovery_mode = TRUE;
            return recovery_token;
        }
    }
    if ((*type_ptr) >= IF) {
        enum TokenType should_be = 0;
        char* closest_keyword = closest_keyword_with_action(keywords, (*a_ptr)->lexeme, action_row, n_states, &should_be);
        if (closest_keyword == NULL)
            return NULL;
        strcpy(msg, "Expected ");
        strcat(msg, closest_keyword);
        strcat(msg, " before '");
        if ((*type_ptr) == 0x04)
            strcat(msg, "eof");
        else if ((*type_ptr) < 128)
            strncat(msg, &((*a_ptr)->c_val), 1);
        else
            strcat(msg, (*a_ptr)->lexeme);
        strcat(msg, "'");
        struct Token* tmp = inject_token(should_be);
        parser_error(len, msg, 0, (*a_ptr)->line, (*a_ptr)->column, 0, 0);
        grammar_error = TRUE;
        struct Token* recovery_token = (*a_ptr);
        (*a_ptr) = tmp;
        (*type_ptr) = tmp->type;
        recovery_mode = TRUE;
        return recovery_token;
    }
    return NULL;
}

/*
 * Syntax error functions. Calls main error function in ../lexing/lexer.c
 */
void int_error(struct Token* token, enum TokenType type)
{
    char msg[LINELENGTH+29];
    if (type == ICONST)
        sprintf(msg, "Did not expect token '%ld'", token->i_val);
    else
        sprintf(msg, "Did not expect token '%lf'", token->f_val);
    parser_error(0, msg, 0, token->line, token->column, 0, 0);

}

void generic_error(struct Token* token, int len)
{
    char msg[29+len];
    strcpy(msg, "Did not expect token '");

    if (token->type < 128)
        strncat(msg, &(token->c_val), 1);
    else
        strcat(msg, token->lexeme);
    strcat(msg, "'");
    parser_error(len, msg, 0, token->line, token->column, 0, 0);
    exit(-1);
}


void return_error()
{
    printf("\n%s:\033[1;31merror\033[0m: Return error at line %d\n", filename, return_line_num);
    printf(" ... |\n");
    printf("     |\n");
    printf("%4d | %s", return_line.num, return_line.line);
    printf("     |");
    for (int i = 0; i < return_col_num; i++)
        printf(" ");
    printf("\033[1;31m^~~~~~~~~~~~~~\033[0m\n");

    printf(" ... |\n\n");
}

struct Token* inject_token(enum TokenType type)
{
    /*
     * Creates a token which is injected into the token stream,
     * to alleviate the damage caused by the user.
     */
    struct Token* imaginary_token = malloc(sizeof(struct Token));
    imaginary_token->type = type;
    if (type != 4 && type < 128)
        imaginary_token->c_val = 'i';
    else
        imaginary_token->lexeme = "imag";

    return imaginary_token;
}

static inline void create_token_record(void*** record_ptr, struct Token* token)
{
    **record_ptr = token;
}



static inline void free_token(struct Token* token)
/*
 * Token destruction. Simple abstraction for readability
 */
{
    enum TokenType type = token->type;
    if (type >= 128 &&
        type != ICONST &&
        type != FCONST)
        if (KeywordTab_get(keywords, token->lexeme) == -1)
            free(token->lexeme);
    free(token);
}

/*
 * Creation of node records by array of function pointers corresponding
 * to reduction rules
 */
void (*record_creator[])(void***) = {

    &reduce_to_compound_compound_list,
    &reduce_to_compound_statement,
    &reduce_to_stmt_vardecl,
    &reduce_to_stmt_structdecl,
    &reduce_to_stmt_funcdecl_,
    &reduce_to_stmt_assignment_statement,
    &reduce_to_stmt_funccall,
    &reduce_to_stmt_ieestmt,
    &reduce_to_stmt_wloop,
    &reduce_to_stmt_floop,
    &reduce_to_stmt_scope,
    &reduce_to_stmt_return,
    &reduce_to_vardecl_w_ind,
    &reduce_to_vardecl_w_ind_n_expr,
    &reduce_to_vardecl,
    &reduce_to_vardecl_w_expr,
    &reduce_to_structdecl_type,
    &reduce_to_decllist_decllist_vardecl,
    &reduce_to_decllist_vardecl,
    &reduce_to_func_decl_w_ind_n_params,
    &reduce_to_func_decl_w_ind,
    &reduce_to_func_decl_w_params,
    &reduce_to_func_decl,
    &reduce_to_empty_ind_list,
    &reduce_to_empty_ind,
    &reduce_to_param_list,
    &reduce_to_param,
    &reduce_to_ind_list_w_expr,
    &reduce_to_ind_w_expr,
    &reduce_to_ind_list,
    &reduce_to_ind,
    &reduce_to_varacc,
    &reduce_to_varacc_w_ind,
    &reduce_to_varacc_list,
    &reduce_to_varacc_w_ind_list,
    &reduce_to_expr_binop,
    &reduce_to_expr_binop,
    &reduce_to_expr_binop,
    &reduce_to_expr_binop,
    &reduce_to_expr_binop,
    &reduce_to_expr_binop,
    &reduce_to_expr_binop,
    &reduce_to_expr_binop,
    &reduce_to_expr_binop,
    &reduce_to_expr_binop,
    &reduce_to_expr_relop,
    &reduce_to_expr_and,
    &reduce_to_expr_or,
    &reduce_to_expr_paren,
    &reduce_to_expr_const,
    &reduce_to_expr_const,
    &reduce_to_expr_const,
    &reduce_to_expr_varacc,
    &reduce_to_expr_funccall,
    &reduce_to_expr_uplus,
    &reduce_to_expr_unary,
    &reduce_to_expr_unary,
    &reduce_to_expr_not,
    &reduce_to_expr_cast,
    &reduce_to_assign,
    &reduce_to_assign,
    &reduce_to_assign_suffixop,
    &reduce_to_funccall_w_args,
    &reduce_to_funccall,
    &reduce_to_args_args,
    &reduce_to_args_expr,
    &reduce_to_ieestmt_ifstmt,
    &reduce_to_ieestmt_eliflist,
    &reduce_to_eliflist_eliflist,
    &reduce_to_eliflist_elif,
    &reduce_to_eliflist_else,
    &reduce_to_cond,
    &reduce_to_cond,
    &reduce_to_else,
    &reduce_to_cond,
    &reduce_to_for_vardecl,
    &reduce_to_for_assign,
    &reduce_to_scope,
    &reduce_to_return,
};

void create_node_record(void*** top, int rule_num)
/*
 * Creation of a node of AST (abstract syntax tree). When the parsers
 * determines a reduction, this function is called. Since the algorithm is
 * stack based, it works from right to left in the production, shifting symbols
 * from the stack into structs of the correct type. Some productions,
 * such as 'indices', generate lists, and while they would naturally produce a
 * linked list if left on their own devices, they are converted to arrays.
 */
{
    //printf("rule num %d\n", rule_num);
    (*record_creator[rule_num-1])(top);


}

/*
 * Reduction case functions.
 */

void reduce_to_compound_compound_list(void*** top)
{
    struct CompStmt* node = malloc(sizeof(struct CompStmt));
    struct Stmt* tmp_stmt = **top;
    (*top)--;

    struct CompStmt* prior_compound = **top;

    int n_new_stmts = prior_compound->n_statements+1;
    node->n_statements = n_new_stmts;
    node->statement_list = malloc(sizeof(struct Stmt*)*n_new_stmts);
    node->statement_list[n_new_stmts-1] = tmp_stmt;
    memcpy(node->statement_list, prior_compound->statement_list,
            sizeof(struct Stmt*)*(n_new_stmts-1));
    free(prior_compound->statement_list);
    free(prior_compound);
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("compound_statement -> compound_statement statement\n\n");
    #endif
    #if TREEBUILDER
    print_CompStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_compound_statement(void*** top)
{
    struct CompStmt* node = malloc(sizeof(struct CompStmt));
    node->n_statements = 1;
    node->statement_list = malloc(sizeof(struct Stmt*));
    node->statement_list[0] = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("compound_statement -> statement\n");
    #endif
    #if TREEBUILDER
    print_CompStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_stmt_vardecl(void*** top)
{
    #if DEBUG || TREEBUILDER
    printf("statement -> variable_declaration ';'\n");
    #endif
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    free_token(**top);
    (*top)--;

    node->statement_type = VARIABLE_DECLARATION;
    node->stmt = **top;
    **top = node;
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_stmt_structdecl(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    node->statement_type = STRUCT_DECLARATION;
    node->stmt = **top;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("statement -> struct_declaration ';'\n");
    #endif
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_stmt_funcdecl_(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    node->statement_type = FUNCTION_DECLARATION;
    node->stmt = **top;
    **top = node;
    return_found = FALSE;
    #if DEBUG || TREEBUILDER
    printf("statement -> function_declaration\n");
    #endif
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_stmt_assignment_statement(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    free_token(**top);
    (*top)--;
    node->statement_type = ASSIGNMENT_STATEMENT;
    node->stmt = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("statement -> assignment_statement ';'\n");
    #endif
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_stmt_funccall(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    free_token(**top);
    (*top)--;
    node->statement_type = FUNCTION_CALL;
    node->stmt = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("statement -> function_call ';'\n");
    #endif
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_stmt_ieestmt(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    node->statement_type = IF_ELIF_ELSE_STATEMENT;
    node->stmt = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("statement -> if_elif_else_statement\n");
    #endif
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_stmt_wloop(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    node->statement_type = WHILE_LOOP;
    node->stmt = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("statement -> while_loop\n");
    #endif
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_stmt_floop(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    node->statement_type = FOR_LOOP;
    node->stmt = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("statement -> for_loop\n");
    #endif
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_stmt_scope(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    node->statement_type = SCOPE;
    node->stmt = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("statement -> scope\n");
    #endif
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_stmt_return(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->next = NULL;

    free(**top);
    (*top)--;
    // Hmmm....
    node->statement_type = RETURN_STATEMENT;
    node->stmt = **top;
    **top = node;
    return_found = TRUE;
    #if DEBUG || TREEBUILDER
    printf("statement -> return_statement ';''\n");
    #endif
    #if TREEBUILDER
    print_Stmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_vardecl_w_ind(void*** top)
{
    struct VarDecl* node = malloc(sizeof(struct VarDecl));
    node->name = **top;
    node->expr = NULL;
    (*top)--;

    struct Inds* ind = **top;
    int n_indices = ind->n_indices;
    node->n_indices = n_indices;
    node->indices = malloc(sizeof(struct Expr*)*n_indices);
    memcpy(node->indices, ind->indices, sizeof(struct Expr*)*n_indices);
    free(ind->indices);
    free(ind);
    (*top)--;

    node->type = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("variable_declaration -> 'ID' indices 'ID'\n");
    #endif
    #if TREEBUILDER
    print_VarDecl(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_vardecl_w_ind_n_expr(void*** top)
{
    struct VarDecl* node = malloc(sizeof(struct VarDecl));
    node->expr = **top;
    (*top)--;

    free(**top);
    (*top)--;

    node->name = **top;
    (*top)--;

    struct Inds* ind = **top;
    int n_indices = ind->n_indices;
    node->n_indices = n_indices;
    node->indices = malloc(sizeof(struct Expr*)*n_indices);
    memcpy(node->indices, ind->indices, sizeof(struct Expr*)*n_indices);
    free(ind->indices);
    free(ind);
    (*top)--;

    node->type = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("variable_declaration -> 'ID' indices 'ID' '=' expr\n");
    #endif
    #if TREEBUILDER
    print_VarDecl(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_vardecl(void*** top)
{
    struct VarDecl* node = malloc(sizeof(struct VarDecl));
    node->n_indices = 0;
    node->indices = NULL;
    node->expr = NULL;

    node->name = **top;
    (*top)--;

    node->type = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("variable_declaration -> 'ID' 'ID'\n");
    #endif
    #if TREEBUILDER
    print_VarDecl(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_vardecl_w_expr(void*** top)
{
    struct VarDecl* node = malloc(sizeof(struct VarDecl));
    node->n_indices = 0;
    node->indices = NULL;

    node->expr = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->name = **top;
    (*top)--;

    node->type = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("variable_declaration -> 'ID' 'ID' '=' expr\n");
    #endif
    #if TREEBUILDER
    print_VarDecl(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_structdecl_type(void*** top)
{
    struct StructDecl* node = malloc(sizeof(struct StructDecl));
    free_token(**top);
    (*top)--;
    struct DeclList* tmp = **top;
    node->bool_arr = tmp->bool_arr;
    node->n_decl = tmp->n_decl;
    node->fields = tmp->fields;
    free(tmp);
    (*top)--;

    free_token(**top);
    (*top)--;

    node->type_name = **top;
    (*top)--;

    free_token(**top);
    **top = node;
    #if DEBUG || TREEBUILDER
    printf(" struct_declaration -> 'STRUCT' 'ID' '{' declaration_list '}'");
    #endif
    #if TREEBUILDER
    print_StructDecl(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_decllist_decllist_vardecl(void*** top)
{
    free_token(**top);
    (*top)--;
    struct VarDecl* tmp = **top;
    (*top)--;
    /*
     * We can save the struct from previous iteration, but need to modify its
     * values
     */
    struct DeclList* node = **top;
    node->n_decl++;
    int n_decl = node->n_decl;
    char* prev_b_arr = node->bool_arr;
    void** prev_decls = node->fields;
    node->bool_arr = malloc(sizeof(char)*n_decl);
    node->fields = malloc(sizeof(void*)*n_decl);
    memcpy(node->bool_arr, prev_b_arr, sizeof(char) * (n_decl-1));
    memcpy(node->fields, prev_decls, sizeof(void*) * (n_decl-1));
    free(prev_b_arr);
    free(prev_decls);
    node->bool_arr[n_decl-1] = 0;
    node->fields[n_decl-1] = tmp;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("declaration_list -> declaration_list variable_declarartion ';'");
    #endif

}

void reduce_to_decllist_vardecl(void*** top)
{
    struct DeclList* node = malloc(sizeof(struct DeclList));
    node->bool_arr = malloc(sizeof(char));
    node->bool_arr[0] = 0;
    node->n_decl = 1;
    free_token(**top);
    (*top)--;

    node->fields = malloc(sizeof(void*));
    node->fields[0] = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("declaration_list -> variable_declarartion ';'");
    #endif
}

void reduce_to_func_decl_w_ind_n_params(void*** top)
{
    struct FuncDecl* node = malloc(sizeof(struct FuncDecl));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Params* params = **top;
    int n_params = params->n_params;
    node->n_params = n_params;
    node->params = malloc(sizeof(struct VarDecl*)*n_params);
    memcpy(node->params, params->params, sizeof(struct VarDecl*)*n_params);
    free(params->params);
    free(params);
    (*top)--;

    free_token(**top);
    (*top)--;

    int* n_empty = **top;
    node->n_indices = *n_empty;
    free(n_empty);
    (*top)--;

    node->name = **top;;
    (*top)--;

    free_token(**top);

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("function_declaration -> 'DEFINE' 'ID' empty_indices 'ID' '(' params ')' '{' compound_statement '}'\n");
    #endif
    #if TREEBUILDER
    print_FuncDecl(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_func_decl_w_ind(void*** top)
{
    struct FuncDecl* node = malloc(sizeof(struct FuncDecl));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    node->n_params = 0;
    node->params = NULL;

    free_token(**top);
    (*top)--;

    int* n_empty = **top;
    node->n_indices = *n_empty;
    free(n_empty);
    (*top)--;

    node->name = **top;
    (*top)--;

    free_token(**top);

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("function_declaration -> 'DEFINE' 'ID' empty_indices 'ID' '(' ')' '{' compound_statement '}'\n");
    #endif
    #if TREEBUILDER
    print_FuncDecl(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_func_decl_w_params(void*** top)
{
    struct FuncDecl* node = malloc(sizeof(struct FuncDecl));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Params* params = **top;
    int n_params = params->n_params;
    node->n_params = n_params;
    node->params = malloc(sizeof(struct VarDecl*)*n_params);
    memcpy(node->params, params->params, sizeof(struct VarDecl*)*n_params);
    free(params->params);
    free(params);
    (*top)--;


    free_token(**top);

    (*top)--;

    node->n_indices = 0;

    node->name = **top;;
    (*top)--;

    node->type = **top;
    (*top)--;

    free_token(**top);
    **top = node;

    #if DEBUG || TREEBUILDER

    printf("function_declaration -> 'DEFINE' 'ID' 'ID' '(' params ')' '{' compound_statement '}'\n");
    #endif
    #if TREEBUILDER
    print_FuncDecl(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_func_decl(void*** top)
{
    struct FuncDecl* node = malloc(sizeof(struct FuncDecl));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    node->n_params = 0;
    node->params = NULL;

    free_token(**top);
    (*top)--;

    node->n_indices = 0;

    node->name = **top;
    (*top)--;

    free_token(**top);
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("function_declaration -> 'DEFINE' 'ID' 'ID' '(' ')' '{' compound_statement '}'\n");
    #endif
    #if TREEBUILDER
    print_FuncDecl(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_empty_ind_list(void*** top)
{
    int* node;
    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    node = **top;
    (*node)++;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("empty_indices -> empty_indices '[' ']'\n");
    #endif

}
//20
void reduce_to_empty_ind(void*** top)
{
    int* node = malloc(sizeof(int));

    free_token(**top);
    (*top)--;
    free_token(**top);

    (*node) = 1;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("empty_indices -> '[' ']'\n");
    #endif

}

void reduce_to_param_list(void*** top)
{
    struct Params* node = malloc(sizeof(struct Params));

    struct VarDecl* next_decl = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Params* prior_params = **top;
    int n_params = prior_params->n_params;
    node->n_params = n_params+1;
    node->params = malloc(sizeof(struct VarDecl*)*(n_params+1));
    node->params[n_params] = next_decl;
    memcpy(node->params, prior_params->params, sizeof(struct Vardecl*)*n_params);
    free(prior_params->params);
    free(prior_params);

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("params -> params ',' variable_declaration\n");
    #endif

}

void reduce_to_param(void*** top)
{
    struct Params* node = malloc(sizeof(struct Params));

    struct VarDecl* next_decl = **top;

    node->n_params = 1;
    node->params = malloc(sizeof(struct VarDecl*));
    node->params[0] = next_decl;

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("params -> variable_declaration\n");
    #endif
}

void reduce_to_ind_list_w_expr(void*** top)
{
    struct Inds* node = malloc(sizeof(struct Inds));

    free_token(**top);
    (*top)--;

    struct Expr* expr = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Inds* prior_node = **top;
    int n_expr = prior_node->n_indices;
    node->n_indices = n_expr+1;
    node->indices = malloc(sizeof(struct Expr*)*(n_expr+1));
    node->indices[n_expr] = expr;
    memcpy(node->indices, prior_node->indices, sizeof(struct Expr*)*n_expr);
    free(prior_node->indices);
    free(prior_node);

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("indices -> indices '[' expr ']'\n");
    #endif

}

void reduce_to_ind_w_expr(void*** top)
{
    struct Inds* node = malloc(sizeof(struct Inds));

    free_token(**top);
    (*top)--;

    struct Expr* expr = **top;
    (*top)--;

    free_token(**top);

    node->n_indices = 1;
    node->indices = malloc(sizeof(struct Expr*));
    node->indices[0] = expr;

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("indices -> '[' expr ']'\n");
    #endif

}

void reduce_to_ind_list(void*** top)
{
    struct Inds* node = malloc(sizeof(struct Inds));

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Inds* prior_node = **top;
    int n_expr = prior_node->n_indices;
    node->n_indices = n_expr+1;
    node->indices = malloc(sizeof(struct Expr*)*(n_expr+1));
    node->indices[n_expr] = NULL;
    memcpy(node->indices, prior_node->indices, sizeof(struct Expr*)*n_expr);
    free(prior_node->indices);
    free(prior_node);

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("indices -> indices '[' ']'\n");
    #endif

}

void reduce_to_ind(void*** top)
{
    struct Inds* node = malloc(sizeof(struct Inds));

    free_token(**top);
    (*top)--;

    free_token(**top);

    node->n_indices = 1;
    node->indices = malloc(sizeof(struct Expr*));
    node->indices[0] = NULL;

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("indices -> '[' ']'\n");
    #endif
}

void reduce_to_varacc(void*** top)
{
    struct VarAcc* node = malloc(sizeof(struct VarAcc));
    node->next = NULL;
    node->n_indices = 0;
    node->indices = NULL;
    node->variable = **top;

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("variable_access -> 'ID'\n");
    #endif
    #if TREEBUILDER
    print_VarAcc(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_varacc_w_ind(void*** top)
{
    struct VarAcc* node = malloc(sizeof(struct VarAcc));
    node->next = NULL;
    struct Inds* ind = **top;
    int n_indices = ind->n_indices;
    node->n_indices = n_indices;
    node->indices = malloc(sizeof(struct Expr*)*n_indices);
    memcpy(node->indices, ind->indices, sizeof(struct Expr*)*n_indices);
    free(ind->indices);
    free(ind);
    (*top)--;

    node->variable = **top;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("variable_access -> 'ID' indices\n");
    #endif
    #if TREEBUILDER
    print_VarAcc(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_varacc_list(void*** top)
{
    struct VarAcc* node = malloc(sizeof(struct VarAcc));
    node->n_indices = 0;
    node->indices = NULL;
    node->variable = **top;
    (*top)--;
    free_token(**top);
    (*top)--;
    node->next = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("variable_access -> variable_access '.' 'ID'\n");
    #endif
    #if TREEBUILDER
    print_VarAcc(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif


}

void reduce_to_varacc_w_ind_list(void*** top)
{
    struct VarAcc* node = malloc(sizeof(struct VarAcc));
    struct Inds* ind = **top;
    int n_indices = ind->n_indices;
    node->n_indices = n_indices;
    node->indices = malloc(sizeof(struct Expr*)*n_indices);
    memcpy(node->indices, ind->indices, sizeof(struct Expr*)*n_indices);
    free(ind->indices);
    free(ind);
    (*top)--;
    node->variable = **top;
    (*top)--;
    free_token(**top);
    (*top)--;
    node->next = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("variable_access -> variable_access '.' 'ID' indices\n");
    #endif
    #if TREEBUILDER
    print_VarAcc(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_expr_binop(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_BINOP;

    node->right = **top;
    (*top)--;

    node->binary_op = **top;
    (*top)--;

    node->left = **top;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("expr -> expr 'binop' expr\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_expr_relop(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_RELOP;

    node->right = **top;
    (*top)--;

    node->binary_op = **top;
    (*top)--;

    node->left = **top;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("expr -> expr 'binop' expr\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_expr_and(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_AND;

    node->right = **top;
    (*top)--;

    node->binary_op = **top;
    (*top)--;

    node->left = **top;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("expr -> expr 'binop' expr\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_expr_or(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_OR;

    node->right = **top;
    (*top)--;

    node->binary_op = **top;
    (*top)--;

    node->left = **top;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("expr -> expr 'binop' expr\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_expr_paren(void*** top)
{
    free_token(**top);
    (*top)--;
    /*
     * Since paranthesis are only for precedence,
     * we can put the expression back on the stack
     * without allocating more memory
     */
    struct Expr* node = **top;
    (*top)--;
    free_token(**top);
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("expr -> '(' expr ')'\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_expr_const(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_CONST;
    node->val = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("expr -> 'EXPR_CONST'\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_expr_varacc(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_VARACC;
    node->variable_access = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("expr -> variable_access\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_expr_funccall(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_FUNCCALL;
    node->function_call = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("expr -> function_call\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_expr_unary(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_UOP;

    node->expr = **top;
    (*top)--;

    node->unary_op = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("expr -> 'uop' expr\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_expr_uplus(void*** top)
{
    /*
     * Since unary plus has no effect, there is no point in storing it.
     */
    struct Expr* node = **top;
    (*top)--;

    free_token(**top);
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("expr -> 'uop' expr\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_expr_not(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_NOT;

    node->expr = **top;
    (*top)--;

    node->unary_op = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("expr -> '!' expr\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_expr_cast(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = EXPR_CAST;

    node->expr = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->unary_op = **top;
    (*top)--;

    free_token(**top);
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("expr -> '(' ID ')' expr\n");
    #endif
    #if TREEBUILDER
    print_Expr(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_assign(void*** top)
{
    struct AStmt* node = malloc(sizeof(struct AStmt));
    node->expr = **top;
    (*top)--;
    node->assignment_type = **top;
    (*top)--;
    node->variable_access = **top;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("assignment_statement -> variable_access 'assign' expr\n");
    #endif
    #if TREEBUILDER
    print_AStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_assign_suffixop(void*** top)
{
    struct AStmt* node = malloc(sizeof(struct AStmt));
    node->assignment_type = **top;
    node->expr = NULL;
    (*top)--;
    node->variable_access = **top;
    **top = node;
    #if DEBUG || TREEBUILDER
    printf("assignment_statement -> variable_access 'SUFFIXOP'\n");
    #endif
    #if TREEBUILDER
    print_AStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_funccall_w_args(void*** top)
{
    struct FuncCall* node = malloc(sizeof(struct FuncCall));
    free_token(**top);
    (*top)--;

    struct Args* prior_args = **top;
    int n_args = prior_args->n_args;
    node->n_args = n_args;
    node->args = malloc(sizeof(struct Expr*)*n_args);
    memcpy(node->args, prior_args->args, sizeof(struct Expr*)*n_args);
    free(prior_args->args);
    free(prior_args);
    (*top)--;

    free_token(**top);
    (*top)--;

    node->func = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("function_call -> 'ID' '(' args ')'\n");
    #endif
    #if TREEBUILDER
    print_FuncCall(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif


}

void reduce_to_funccall(void*** top)
{
    struct FuncCall* node = malloc(sizeof(struct FuncCall));
    free_token(**top);
    (*top)--;

    node->n_args = 0;
    node->args = NULL;

    free_token(**top);
    (*top)--;

    node->func = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("function_call -> 'ID' '(' ')'\n");
    #endif
    #if TREEBUILDER
    print_FuncCall(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_args_args(void*** top)
{
    struct Args* node = malloc(sizeof(struct Args));
    struct Expr* next_arg = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Args* prior_args = **top;
    int n_args = prior_args->n_args;
    node->n_args = n_args+1;
    node->args = malloc(sizeof(struct Expr*)*(n_args+1));
    node->args[n_args] = next_arg;
    memcpy(node->args, prior_args->args, sizeof(struct Expr*)*n_args);
    free(prior_args->args);
    free(prior_args);

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("args -> args ',' expr\n");
    #endif

}

void reduce_to_args_expr(void*** top)
{
    struct Args* node = malloc(sizeof(struct Args));
    node->n_args = 1;
    node->args = malloc(sizeof(struct Expr*));
    node->args[0] = **top;

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("args -> expr\n");
    #endif
}

void reduce_to_ieestmt_ifstmt(void*** top)
{
    struct IEEStmt* node = malloc(sizeof(struct IEEStmt));
    node->n_elifs = 0;
    node->elif_list = NULL;
    node->_else = NULL;
    node->if_stmt = **top;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("if_elif_else_statement -> if_statement\n");
    #endif
    #if TREEBUILDER
    print_IEEStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_ieestmt_eliflist(void*** top)
{
    struct IEEStmt* node = malloc(sizeof(struct IEEStmt));
    struct EList* elif_list = **top;

    int n_elifs = elif_list->n_elifs;

    node->n_elifs = n_elifs;
    node->_else = elif_list->_else;

    if (n_elifs) {
        node->elif_list = malloc(sizeof(struct CondStmt*)*n_elifs);
        memcpy(node->elif_list, elif_list->elif_list, sizeof(struct CondStmt*)*n_elifs);
        free(elif_list->elif_list);
    } else {
        node->elif_list = NULL;
    }
    free(elif_list);
    (*top)--;

    node->if_stmt = **top;

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("if_elif_else_statement -> if_statement elif_list\n");
    #endif
    #if TREEBUILDER
    print_IEEStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_eliflist_eliflist(void*** top)
{
    struct EList* node = malloc(sizeof(struct EList));
    struct EList* prior_list = **top;
    (*top)--;
    int n_elifs = prior_list->n_elifs;
    if (n_elifs != 0) {
        node->n_elifs = n_elifs+1;
        node->elif_list = malloc(sizeof(struct CondStmt*)*(n_elifs+1));
        memcpy(node->elif_list+1, prior_list->elif_list, sizeof(struct CondStmt*)*n_elifs);
        free(prior_list->elif_list);
    } else {
        node->n_elifs = 1;
        node->elif_list = malloc(sizeof(struct CondStmt*));
    }

    node->_else = prior_list->_else;
    free(prior_list);

    node->elif_list[0] = **top;
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("elif_list -> elif_statement elif_list\n");
    #endif

}

void reduce_to_eliflist_elif(void*** top)
{
    struct EList* node = malloc(sizeof(struct EList));
    node->n_elifs = 1;
    node->elif_list = malloc(sizeof(struct CondStmt*));
    node->elif_list[0] = **top;
    node->_else = NULL;

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("elif_list -> elif_statement\n");
    #endif

}

void reduce_to_eliflist_else(void*** top)
{
    struct EList* node = malloc(sizeof(struct EList));
    node->n_elifs = 0;
    node->elif_list = NULL;
    node->_else = **top;

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("elif_list -> else_statement\n");
    #endif
}

void reduce_to_cond(void*** top)
{
    struct CondStmt* node = malloc(sizeof(struct CondStmt));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->boolean = **top;
    (*top)--;

    free_token(**top);

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("cond_statement -> 'keyword' b_expr '{' compound_statement '}'\n");
    #endif
    #if TREEBUILDER
    print_CondStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_else(void*** top)
{
    /*
     * Similiar to a paranthesized expressions, the memory for an else is
     * already allocated by compound statement functions
     */
    struct CompStmt* node;
    free_token(**top);
    (*top)--;

    node = **top;
    (*top)--;

    free_token(**top);
    (*top)--;
    free_token(**top);

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("else_statement -> 'ELSE' '{' compound_statement '}'\n");
    #endif
    #if TREEBUILDER
    print_CompStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_for_vardecl(void*** top)
{
    struct FLoop* node = malloc(sizeof(struct FLoop));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;
    free_token(**top);
    (*top)--;
    node->update_statement = **top;
    (*top)--;
    free_token(**top);
    (*top)--;

    node->boolean = **top;
    (*top)--;
    free_token(**top);
    (*top)--;

    node->type = VARIABLE_DECLARATION;
    node->init_stmt = **top;
    (*top)--;
    free_token(**top);

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("for_loop -> 'FOR' variable_declaration ',' b_expr ',' assignment_statement '{' compound_statement '}'\n");
    #endif
    #if TREEBUILDER
    print_FLoop(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_for_assign(void*** top)
{
    struct FLoop* node = malloc(sizeof(struct FLoop));

    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->update_statement = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->boolean = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->type = ASSIGNMENT_STATEMENT;
    node->init_stmt = **top;

    (*top)--;

    free_token(**top);

    **top = node;

    #if DEBUG || TREEBUILDER
    printf("for_loop -> 'FOR' assignment_statement ',' b_expr ',' assignment_statement '{' compound_statement '}'\n");
    #endif
    #if TREEBUILDER
    print_FLoop(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif

}

void reduce_to_scope(void*** top)
{
    free_token(**top);
    (*top)--;

    struct CompStmt* node = **top;
    (*top)--;

    free_token(**top);

    **top = node;
    #if DEBUG || TREEBUILDER
    printf("scope -> '{' compound_statement '}'\n");
    #endif
    #if TREEBUILDER
    print_CompStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

void reduce_to_return(void*** top)
{
    struct Expr* node;
    node = **top;
    (*top)--;

    free_token(**top);
    **top = node;

    #if DEBUG || TREEBUILDER
    printf("return_statement -> 'RETURN' expr\n");
    #endif
    #if TREEBUILDER
    print_ReturnStmt(**top, 0, 1, 1);
    printf("\n");
    printf("----------------------------------------------------------\n");
    printf("\n");
    #endif
}

/*
 * Print functions. There are some cryptic parameters...
 */

static inline void write_indent(int nest_level)
{
    for (int i = 0; i < nest_level; i++)
        printf("    ");
}

void print_CompStmt(struct CompStmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("CompStmt\n");
    for (int i = 0; i < node->n_statements; i++) {
        print_Stmt(node->statement_list[i], nest_level+1, labels, leaf);
    }
}

void print_Stmt(struct Stmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("Stmt\n");
    switch (node->statement_type) {
        case VARIABLE_DECLARATION:
            print_VarDecl(node->stmt, nest_level+1, labels, leaf);
            return;
        case FUNCTION_DECLARATION:
            print_FuncDecl(node->stmt, nest_level+1, labels, leaf);
            return;
        case STRUCT_DECLARATION:
            print_StructDecl(node->stmt, nest_level+1, labels, leaf);
            return;
        case ASSIGNMENT_STATEMENT:
            print_AStmt(node->stmt, nest_level+1, labels, leaf);
            return;
        case FUNCTION_CALL:
            print_FuncCall(node->stmt, nest_level+1, labels, leaf);
            return;
        case IF_ELIF_ELSE_STATEMENT:
            print_IEEStmt(node->stmt, nest_level+1, labels, leaf);
            return;
        case WHILE_LOOP:
            print_WLoop(node->stmt, nest_level+1, labels, leaf);
            return;
        case FOR_LOOP:
            print_FLoop(node->stmt, nest_level+1, labels, leaf);
            return;
        case SCOPE:
            print_CompStmt(node->stmt, nest_level+1, labels, leaf);
            return;
        case RETURN_STATEMENT:
            print_ReturnStmt(node->stmt, nest_level+1, labels, leaf);
        default:
            break;
    }
}

void print_VarDecl(struct VarDecl* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    if (labels) {
        printf("VarDecl");
        if (node->indices) {
            printf(" %dd", node->n_indices);
        }
        if (node->expr != NULL) {
            printf(" = expr\n");
        } else {
            printf("\n");
        }
    } else {
        printf("decl: ");
        print_token_str(node->name);
        printf(" of type ");
        print_token_str(node->type);
        printf("\n");
        for (int i = 0; i < node->n_indices; i++) {
            write_indent(nest_level);
            printf("[\n");
            print_Expr(node->indices[i], nest_level+1, labels, leaf);
            write_indent(nest_level);
            printf("]\n");
        }
    }
}

void print_StructDecl(struct StructDecl* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("Struct");
    if (!labels)
        if (node->type_name != NULL)
            printf(" '%s'", node->type_name->lexeme);
    printf("\n");
    for (int i = 0; i < node->n_decl; i++) {
        if (node->bool_arr[i])
            print_StructDecl(node->fields[i], nest_level+1, labels, leaf);
        else
            print_VarDecl(node->fields[i], nest_level+1, labels, leaf);
    }
}

void print_FuncDecl(struct FuncDecl* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    if (labels) {
        printf("FuncDecl");
        if (node->n_indices) {
            printf(" %dd", node->n_indices);
        }
        printf(" %d params\n", node->n_params);
        print_CompStmt(node->body, nest_level+1, labels, leaf);
    } else {
        printf("func: ");
        print_token_str(node->name);
        printf(" of type ");
        print_token_str(node->type);
        printf(" %dd\n", node->n_indices);
        for (int i = 0; i < node->n_params; i++) {
            write_indent(nest_level);
            printf("\n");
            print_VarDecl(node->params[i], nest_level+1, labels, leaf);
            write_indent(nest_level);
            printf("\n");
        }
        write_indent(nest_level);
        printf(") {");
        print_CompStmt(node->body, nest_level+1, labels, leaf);
    }
}

void print_VarAcc(struct VarAcc* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    if (leaf) {
        printf("Acc");
        print_token_str(node->variable);
        printf("\n");
        for (int i = 0; i < node->n_indices; i++)
            printf("[]");
        printf("\n");
        if (node->next != NULL)
            print_VarAcc(node->next, nest_level+1, labels, leaf);
    } else if (labels) {
        print_token_str(node->variable);
        for (int i = 0; i < node->n_indices; i++)
            printf("[]");
        printf("\n");
        if (node->next != NULL)
            print_VarAcc(node->next, nest_level+1, labels, leaf);
    }
    else {
        print_token_str(node->variable);
        for (int i = 0; i < node->n_indices; i++) {
            printf("\n");
            write_indent(nest_level);
            printf("[\n");
            print_Expr(node->indices[i], nest_level+1, labels, leaf);
            write_indent(nest_level);
            printf("]\n");
            if (node->next != NULL)
                print_VarAcc(node->next, nest_level+1, labels, leaf);
        }
    }
}

void print_Expr(struct Expr* node, int nest_level, char labels, char leaf)
{
    if (leaf) {
        switch (node->type) {
            case EXPR_BINOP:
            case EXPR_RELOP:
            case EXPR_AND:
            case EXPR_OR:
                print_Expr(node->left, nest_level+1, labels, leaf);
                write_indent(nest_level);
                print_token_str(node->binary_op);
                printf("\n");
                print_Expr(node->right, nest_level+1, labels, leaf);
                return;
            case EXPR_NOT:
            case EXPR_UOP:
                write_indent(nest_level);
                print_token_str(node->unary_op);
                printf("\n");
                print_Expr(node->expr, nest_level+1, labels, leaf);
                return;
            case EXPR_CONST:
                write_indent(nest_level);
                print_token_str(node->val);
                printf("\n");
                return;
            case EXPR_FUNCCALL:
                write_indent(nest_level);
                print_token_str(node->function_call->func);
                printf("\n");
                return;
            case EXPR_VARACC:
                write_indent(nest_level);
                print_token_str(node->variable_access->variable);
                printf("\n");
                return;
            case EXPR_CAST:
                write_indent(nest_level);
                printf("(%s)\n", node->unary_op->lexeme);
                print_Expr(node->expr, nest_level+1, labels, leaf);
                return;
        }
    } else {
        switch (node->type) {
            case EXPR_BINOP:
            case EXPR_RELOP:
            case EXPR_AND:
            case EXPR_OR:
                print_Expr(node->left, nest_level+1, labels, leaf);
                write_indent(nest_level);
                print_token_str(node->binary_op);
                printf("\n");
                print_Expr(node->right, nest_level+1, labels, leaf);
                return;
            case EXPR_UOP:
            case EXPR_NOT:
                write_indent(nest_level);
                print_token_str(node->unary_op);
                printf("\n");
                print_Expr(node->expr, nest_level+1, labels, leaf);
                return;
            case EXPR_CONST:
                write_indent(nest_level);
                print_token_str(node->val);
                printf("\n");
                return;
            case EXPR_FUNCCALL:
                print_FuncCall(node->function_call, nest_level, labels, leaf);
                return;
            case EXPR_VARACC:
                print_VarAcc(node->variable_access, nest_level, labels, leaf);
                return;
            case EXPR_CAST:
                write_indent(nest_level);
                printf("(%s)\n", node->unary_op->lexeme);
                print_Expr(node->expr, nest_level+1, labels, leaf);
                return;
        }
    }
}

void print_AStmt(struct AStmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);


    if (leaf) {
        printf("var ");
        if (node->assignment_type->type == SUFFIXOP) {
            print_token_str(node->assignment_type);
            printf("\n");
        }
        else {
            print_token_str(node->assignment_type);
            printf(" expr\n");
        }
    } else if (labels) {
        printf("Assign\n");
    } else {
        printf("Assignment\n");
        print_VarAcc(node->variable_access, nest_level+1, labels, leaf);
        printf("\n");
        write_indent(nest_level);
        printf("by ");
        print_token_str(node->assignment_type);
        printf("\n");
        print_Expr(node->expr, nest_level+1, labels, leaf);
    }
}

void print_FuncCall(struct FuncCall* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    if (labels) {
        printf("FuncCall\n");
    } else {
        printf("Call ");
        print_token_str(node->func);
        printf("with: \n");
        for (int i = 0; i < node->n_args; i++) {
            print_Expr(node->args[i], nest_level+1, labels, leaf);
        }
    }

}

void print_IEEStmt(struct IEEStmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("if:\n");
    print_CondStmt(node->if_stmt, nest_level, labels, leaf);
    for (int i = 0; i < node->n_elifs; i++) {
        write_indent(nest_level);
        printf("elif:\n");
        print_CondStmt(node->elif_list[i], nest_level, labels, leaf);
    }
    if (node->_else != NULL) {
        write_indent(nest_level);
        printf("else:\n");
        print_CompStmt(node->_else, nest_level+1, labels, leaf);
    }
}

void print_CondStmt(struct CondStmt* node, int nest_level, char labels, char leaf)
{
    if (!labels)
        print_Expr(node->boolean, nest_level+1, labels, leaf);
    print_CompStmt(node->body, nest_level+1, labels, leaf);
}

void print_WLoop(struct CondStmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("while\n");
    print_CondStmt(node, nest_level, labels, leaf);
}

void print_FLoop(struct FLoop* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("for:\n");
    if (!labels) {
        if (node->type == VARIABLE_DECLARATION) {
            print_VarDecl(node->init_stmt, nest_level+1, labels, leaf);
        } else {
            print_AStmt(node->init_stmt, nest_level+1, labels, leaf);
        }
        write_indent(nest_level);
        printf(",\n");
        print_Expr(node->boolean, nest_level+1, labels, leaf);
        write_indent(nest_level);
        printf(",\n");
        print_AStmt(node->update_statement, nest_level+1, labels, leaf);
        printf(",\n");
    }
    print_CompStmt(node->body, nest_level+1, labels, leaf);
}

void print_ReturnStmt(struct Expr* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("return\n");
    if (leaf) {
        print_Expr(node, nest_level+1, labels, leaf);
    }
}


/*
 * Tree destruction functions.
 */

void free_CompStmt(struct CompStmt* node)
{
    for (int i = 0; i < node->n_statements; i++) {
        free_Stmt(node->statement_list[i]);
    }
    free(node->statement_list);
    free(node);
}

void free_Stmt(struct Stmt* node)
{
    switch (node->statement_type) {
        case VARIABLE_DECLARATION:
            free_VarDecl(node->stmt);
            break;
        case FUNCTION_DECLARATION:
            free_FuncDecl(node->stmt);
            break;
        case ASSIGNMENT_STATEMENT:
            free_AStmt(node->stmt);
            break;
        case FUNCTION_CALL:
            free_FuncCall(node->stmt);
            break;
        case IF_ELIF_ELSE_STATEMENT:
            free_IEEStmt(node->stmt);
            break;
        case WHILE_LOOP:
            free_CondStmt(node->stmt);
            break;
        case FOR_LOOP:
            free_FLoop(node->stmt);
            break;
        case SCOPE:
            free_CompStmt(node->stmt);
            break;
        case RETURN_STATEMENT:
            free_Expr(node->stmt);
            break;
        default:
            break;
    }
    free(node);
}

void free_VarDecl(struct VarDecl* node)
{
    free_token(node->type);
    if (node->n_indices > 0) {
        for (int i = 0; i < node->n_indices; i++)
            free_Expr(node->indices[i]);

        free(node->indices);
    }
    free_token(node->name);
    if (node->expr != NULL)
        free_Expr(node->expr);
    free(node);
}

void free_FuncDecl(struct FuncDecl* node)
{
    free_token(node->type);
    free_token(node->name);
    for (int i = 0; i < node->n_params; i++)
        free_VarDecl(node->params[i]);
    free(node->params);
    free_CompStmt(node->body);
    free(node);
}

void free_VarAcc(struct VarAcc* node)
{
    free_token(node->variable);
    for (int i = 0; i < node->n_indices; i++)
        free_Expr(node->indices[i]);
    if (node->next != NULL)
        free_VarAcc(node->next);
    free(node->indices);
    free(node);
}

void free_Expr(struct Expr* node)
{
        switch (node->type) {
        case EXPR_BINOP:
        case EXPR_RELOP:
        case EXPR_AND:
        case EXPR_OR:
            free_Expr(node->left);
            free_token(node->binary_op);
            free_Expr(node->right);
            break;
        case EXPR_CAST:
        case EXPR_UOP:
        case EXPR_NOT:
            free_token(node->unary_op);
            free_Expr(node->expr);
            break;
        case EXPR_CONST:
            free_token(node->val);
            break;
        case EXPR_FUNCCALL:
            free_FuncCall(node->function_call);
            break;
        case EXPR_VARACC:
            free_VarAcc(node->variable_access);
            break;
    }
    free(node);
}

void free_AStmt(struct AStmt* node)
{

    free_VarAcc(node->variable_access);
    free_token(node->assignment_type);
    if (node->expr != NULL)
        free_Expr(node->expr);
    free(node);
}

void free_FuncCall(struct FuncCall* node)
{
    free_token(node->func);
    for (int i = 0; i < node->n_args; i++)
        free_Expr(node->args[i]);
    free(node->args);
    free(node);
}

void free_IEEStmt(struct IEEStmt* node)
{
    free_CondStmt(node->if_stmt);
    if (node->n_elifs > 0) {
        for (int i = 0; i < node->n_elifs; i++)
            free_CondStmt(node->elif_list[i]);
        free(node->elif_list);
    }
    if (node->_else != NULL)
        free_CompStmt(node->_else);
    free(node);
}

void free_CondStmt(struct CondStmt* node)
{
    free_Expr(node->boolean);
    free_CompStmt(node->body);
    free(node);
}

void free_FLoop(struct FLoop* node)
{
    if (node->type == VARIABLE_DECLARATION)
        free_VarDecl(node->init_stmt);
    else
        free_AStmt(node->init_stmt);
    free_Expr(node->boolean);
    free_AStmt(node->update_statement);
    free_CompStmt(node->body);
    free(node);
}
