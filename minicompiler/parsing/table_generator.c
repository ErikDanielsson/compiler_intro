#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "table_generator.h"
/*
 * Reads file generated by parser generator 'LALR.py' and generates parse table
 * for 'parser.c'
 */


char** rules;
int* reduction_rules;
int* n_pop_states;
int** action_table;
int n_states;
int** goto_table;
int n_rules = 0;
int n_states = 0;
int n_terminals = 0;
int n_nonterminals = 0;

void generate_parse_table(const char* filename)
{
    FILE* file_desc;
    char* line = NULL;
    size_t len = 0;
    ssize_t read = 0;
    file_desc = fopen(filename, "r");
    if (file_desc == NULL) {
        fprintf(stderr, "ERROR:Unable to open parse table file\n");
        exit(EXIT_FAILURE);
    }

    /*
     * Pass over file once to calculate lengths of arrays
     */

    // Count number of productions
    while (getline(&line, &len, file_desc) != -1) {
        if (line[0] == 'R' && line[1] == '\n')
            continue;
        if (line[0] == 'A' && line[1] == '\n')
            break;
        n_rules++;
    }
    // Read line with number of terminals
    read = getline(&line, &len, file_desc);
    char c  = line[0];
    for (int i = 0; isdigit(c); i++) {
        n_terminals = n_terminals*10 + c-0x30;
        c  = line[i+1];
    }
    n_terminals++;

    // Count number of states
    while ((read = getline(&line, &len, file_desc)) != -1) {

        if (line[0] == 'r' && line[1] == '\n')
            break;
        n_states++;
    }
    // Skip reduction rule lines
    while ((read = getline(&line, &len, file_desc)) != -1) {
        if (line[0] == 'G' && line[1] == '\n')
            break;
    }
    // Count nonterminals
    while ((read = getline(&line, &len, file_desc)) != -1) {
        if (line[0] == 'G' && line[1] == '\n')
            continue;
        n_nonterminals++;
    }
    fclose(file_desc);
    free(line);

    /*
     * Pass over file once more and write to arrays
     */

    file_desc = fopen(filename, "r");
     if (file_desc == NULL)
         exit(EXIT_FAILURE);

     line = NULL;
     len = 0;
     getline(&line, &len, file_desc); // Read line with 'R'

    // Write rules for verbose parsing to array
    rules = malloc(sizeof(char*)*n_rules);
     for (int i = 0; i < n_rules; i++) {
         read = getline(&line, &len, file_desc);
         rules[i] = malloc(sizeof(char)*(read+1));
         strcpy(rules[i], line);
     }

     getline(&line, &len, file_desc); // Read line with n_terminals
     getline(&line, &len, file_desc); // Read line with 'A'

    // Action table entries
     action_table = malloc(sizeof(int*)*n_states);
     for (int i = 0; i < n_states; i++) {
         action_table[i] = malloc(sizeof(int)*n_terminals);
         // Map erroneous entries to values above maximum state number
         for (int j = 0; j < n_terminals; j++)
             action_table[i][j] = n_states;
         getline(&line, &len, file_desc);
         for (int j = 0; line[j] != '\n';) {
             int index = 0;
             int value = 0;
             for (;isdigit(line[j]); j++) {
                 index = index*10 + line[j]-0x30;
             }
             j++;
             char b = (line[j] == '-');
             j += b;
             for (;isdigit(line[j]); j++)
                 value = value*10 + line[j]-0x30;
             action_table[i][index] = value - b*2*value;
             j++;
         }
     }

     getline(&line, &len, file_desc); // Read line with 'r'

    // Reduction rules, i.e. mapping from production to symbol
    getline(&line, &len, file_desc);
     reduction_rules = malloc(sizeof(int)*n_rules);
     int index = 0;
     for (int i = 0; line[i] != '\n'; index++) {
         int tmp = 0;
         while (line[i] != ',') {
             tmp = tmp*10 + line[i]-0x30;
             i++;
         }
         i++;
         reduction_rules[index] = tmp;
     }

    // Lengths of productions <=> number of states popped during reduction
     getline(&line, &len, file_desc);
     n_pop_states = malloc(sizeof(int)*n_rules);
     index = 0;
     for (int i = 0; line[i] != '\n'; index++) {
         int tmp = 0;
         while (line[i] != ',') {
             tmp = tmp*10 + line[i]-0x30;
             i++;
         }
         i++;
         n_pop_states[index] = tmp;
     }

     getline(&line, &len, file_desc); // Read line with G

    // Goto table entries
     goto_table = malloc(sizeof(int*)*n_nonterminals);
     for (int i = 0; i < n_nonterminals; i++) {
         read = getline(&line, &len, file_desc);
         if (read == 1) {
             goto_table[i] = NULL;
             continue;
         }
         goto_table[i] = malloc(sizeof(int)*n_states);
         for (int q = 0; q < n_states; q++)
             goto_table[i][q] = -1;
         for (int j = 0; line[j] != '\n';) {
             int index = 0;
             int value = 0;
             for (;isdigit(line[j]); j++) {
                 index = index*10 + line[j]-0x30;
             }
             j++;
             for (;isdigit(line[j]); j++)
                 value = value*10 + line[j]-0x30;
             goto_table[i][index] = value;
             j++;
         }
     }
     fclose(file_desc);
    free(line);
}

void destroy_parse_table()
{
    for (int i = 0; i < n_rules; i++) {
        free(rules[i]);
    }
    free(rules);

    for (int i = 0; i < n_states; i++)
        free(action_table[i]);

    free(action_table);

    for (int i = 0; i < n_nonterminals; i++)
        if (goto_table[i] != NULL)
            free(goto_table[i]);

    free(goto_table);

    free(reduction_rules);

    free(n_pop_states);

}
