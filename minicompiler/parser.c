#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include "lexer.h"
#include "symbol_table.h"
#include "parser.h"
#include "table_generator.h"

#define STACK_SIZE 8192
#define TRUE 1
#define FALSE 0
#define VERBOSE 1
#define DEBUG 1
#define TREEBUILDER 1
#define LABELS 0
char grammar_error = FALSE;
char recovery_mode = FALSE;
/*
 * Since nested function declaration and return statementnot within function
 * bodies are allowed by the grammar according to the grammar, enforcing these
 * rules are handled by the following variable which are set during parsing
 * according to context.
 * Note: while enforcing this in the grammar would be possible, this requieres
 * duplication of several productions and is thus wasteful.
 */
char return_found = FALSE;
char return_row[LINELENGTH];
int return_line_num;
int return_col_num;
char func_decl_found = FALSE;

/*
 * bla bla bla
 *
 */

struct CompStmt* lr_parser(char verbose)
/*
 * Stack machine for LR parsing. Uses a LALR parsing table and generated by
 * "table_generator.c", and produces a parse of the token stream from the lexer.
 */
{

    #if DEBUG
    printf("parsing...\n");
    #endif
    void* tree_stack[STACK_SIZE];
    void** record_ptr = tree_stack;
    int stack[STACK_SIZE];
    int* s_ptr = stack;
    struct Token* a = get_token();
    enum TokenType type = a->type;
    struct Token* recovery_token = NULL;
    *s_ptr = 0;
    *record_ptr = NULL;

    int action;
    parsing_loop:
    while (1) {
        action = action_table[*s_ptr][type];

        #if DEBUG
        printf("Stack depth %ld, top: %d\n", s_ptr-stack, *s_ptr);
        printf("action %d lexeme: ", action);
        print_token_str(a);
        printf(", %x\n", type);
        #endif

        if (action >= n_states) {
            printf("error in state %d on input ", *s_ptr);
            if (type == 0x04)
                printf("'EOF'\n");
            else
                print_token_str(a);
            printf("type %d", a->type);
            printf("\n");
            #if DEBUG
            printf("Stack: ");
            for (int i = 0; i <=  s_ptr-stack; i++)
                printf("%d, ", *(stack+i));
            printf("\n");
            #endif
            int* row = action_table[*s_ptr];
            int len;
            if (type < 128)
                len = 1;
            else
                len = strlen(a->lexeme);
            if ((recovery_token = insertion_fix(row, len, &a, &type)) != NULL) {
                printf("rec\n");
                printf("in error: ");
                print_token_str(recovery_token);
                printf("\n");
                print_token_str(a);
                printf("\n");
                goto parsing_loop;
            }
            free_token(a);
            parser_error(len, "", 0, a->line, a->column, 0, 0);
            return NULL;

        } else if (action >= 0) {
            s_ptr++;
            #if DEBUG
            printf("Push %d\n", action);
            #endif
            *s_ptr = action;
            record_ptr++;
            create_token_record(&record_ptr, a);
            if (recovery_mode) {
                #if DEBUG
                printf("IN RECORVERY\n");
                #endif
                a = recovery_token;
                type = a->type;
                recovery_mode = FALSE;
                exit(0);
            } else {
                a = get_token();
                type = a->type;
                if (type == RETURN) {
                    char* tmp = return_row;
                    return_line_num = copy_current_line(&tmp);
                    return_col_num = a->column;
                }
            }

        } else if (action == -1) {
            #if VERBOSE
            printf("parse done\n");
            print_CompStmt((struct CompStmt*)(*record_ptr), 0, 1, 0);
            #endif
            free(a); // struct Token* a is necessarily eof, therefore no lexeme
            return (struct CompStmt*)(*record_ptr);

        } else {
            action = -(action+1);
            enum NodeType r = reduction_rules[action];

            int n_pop = n_pop_states[action];
            s_ptr -= n_pop;
            int tmp = *s_ptr;
            s_ptr++;
            *s_ptr = goto_table[r][tmp];
            #if DEBUG
            printf("r num %d\n", action);
            #endif
            create_node_record(&record_ptr, action);
            #if DEBUG
            printf("reduce by %s\n", rules[action]);
            #endif
        }
    }
}

void parser_error(int length, const char* expected,
          int fatal, int line, int column,
          int inject_symbol, char symbol)
{
    /*
     * Calls error func implemented in "lexer.c"
     */
    error("syntax error", length, expected, fatal, line, column,
        inject_symbol, symbol);
}

struct Token* insertion_fix(int* action_row, int len, struct Token** a_ptr, enum TokenType* type_ptr)
{
    char msg[20+len+3];
    char anker_symbols[] = {';', '}'};
    for (char i = 0; i < 2; i++) {
        char symbol = anker_symbols[i];
        if (action_row[symbol] < n_states) {
            printf("SYMBOL: %c\n", symbol);
            printf("ACTION: %d\n", -action_row[symbol]-1);
            strcpy(msg, "Expected ");
            printf("SYMBOL: %c\n", symbol);
            strncat(msg, &symbol, 1);
            printf("SYMBOL: %c\n", symbol);
            strcat(msg, " before '");
            if ((*type_ptr) == 0x04)
                strcat(msg, "eof");
            else if ((*type_ptr) < 128)
                strncat(msg, &((*a_ptr)->c_val), 1);
            else
                strcat(msg, (*a_ptr)->lexeme);
            strcat(msg, "'");
            printf("SYMBOL: %c\n", symbol);
            struct Token* tmp = inject_token(symbol);
            printf("SYMBOL: %c\n", symbol);
            parser_error(len, msg, 0, (*a_ptr)->line, (*a_ptr)->column, -1, symbol);
            grammar_error = TRUE;
            struct Token* recovery_token = (*a_ptr);
            (*a_ptr) = tmp;
            (*type_ptr) = tmp->type;
            recovery_mode = TRUE;
            return recovery_token;
        }
    }
    return NULL;
}

void return_error()
{
    printf("\n%s:\033[1;31merror\033[0m: Return error at line %d\n", filename, return_line_num);
    printf(" ... |\n");
    printf("     |\n");
    printf("%4d | %s", return_line_num, return_row);
    printf("     |");
    for (int i = 0; i < return_col_num; i++)
        printf(" ");
    printf("\033[1;31m^~~~~~~~~~~~~~\033[0m\n");

    printf(" ... |\n\n");
}

struct Token* inject_token(enum TokenType type) {
    /*
     * Creates a token which is injected into the token stream,
     * to alleviate the damage caused by the user.
     */
    struct Token* imaginary_token = malloc(sizeof(struct Token));
    imaginary_token->type = type;
    if (type != 4 && type < 128)
        imaginary_token->c_val = 'i';
    else
        imaginary_token->lexeme = "imag";

    return imaginary_token;
}

static inline void create_token_record(void*** record_ptr, struct Token* token)
{
    **record_ptr = token;
}



static inline void free_token(struct Token* token)
/*
 * Token destruction. Simple abstraction for readability
 */
{
    if (token->type >= 128)
        free(token->lexeme);
    free(token);
}

void create_node_record(void*** top, int rule_num)
/*
 * Creation of a node of AST (abstract syntax tree). When the parsers
 * determines a reduction, this function is called. Since the algorithm is
 * stack based, it works from right to left in the production, shifting symbols
 * from the stack into structs of the correct type. Some productions,
 * such as'indices', generate lists, and while they would naturally produce a
 * linked list if left on their own, they are converted to arrays.
 */
{
    switch (rule_num) {
        case 1:
            #if DEBUG || TREEBUILDER
            printf("compound_statement -> compound_statement statement\n\n");
            #endif
            reduce_to_compound_compound_list(top);
            #if TREEBUILDER
            print_CompStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;
        case 2:
            #if DEBUG || TREEBUILDER
            printf("compound_statement -> statement\n");
            #endif
            reduce_to_compound_statement(top);
            #if TREEBUILDER
            print_CompStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;
        case 3:
            #if DEBUG || TREEBUILDER
            printf("(3) statement -> variable_declaration ';'\n");
            #endif
            reduce_to_stmt_vardecl(top);
            #if TREEBUILDER
            print_Stmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 4:
            #if DEBUG || TREEBUILDER
            printf("(4) statement -> function_declaration\n");
            #endif
            reduce_to_stmt_funcdecl_(top);
            #if TREEBUILDER
            print_Stmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 5:
            #if DEBUG || TREEBUILDER
            printf("(5) statement -> assignment_statement ';'\n");
            #endif
            reduce_to_stmt_assignment_statement(top);
            #if TREEBUILDER
            print_Stmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 6:
            #if DEBUG || TREEBUILDER
            printf("(6) statement -> function_call ';'\n");
            #endif
            reduce_to_stmt_funccall(top);
            #if TREEBUILDER
            print_Stmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 7:
            #if DEBUG || TREEBUILDER
            printf("(7) statement -> if_elif_else_statement\n");
            #endif
            reduce_to_stmt_ieestmt(top);
            #if TREEBUILDER
            print_Stmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 8:
            #if DEBUG || TREEBUILDER
            printf("(8) statement -> while_loop\n");
            #endif
            reduce_to_stmt_wloop(top);
            #if TREEBUILDER
            print_Stmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 9:
            #if DEBUG || TREEBUILDER
            printf("(9) statement -> for_loop\n");
            #endif
            reduce_to_stmt_floop(top);
            #if TREEBUILDER
            print_Stmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 10:
            #if DEBUG || TREEBUILDER
            printf("(10) statement -> scope\n");
            #endif
            reduce_to_stmt_scope(top);
            #if TREEBUILDER
            print_Stmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 11:
            #if DEBUG || TREEBUILDER
            printf("(11) statement -> return_statement ';''\n");
            #endif
            reduce_to_stmt_return(top);
            #if TREEBUILDER
            print_Stmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 12:
            #if DEBUG || TREEBUILDER
            printf("(12) variable_declaration -> 'ID' indices 'ID'\n");
            #endif
            reduce_to_vardecl_w_ind(top);
            #if TREEBUILDER
            print_VarDecl(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 13:
            #if DEBUG || TREEBUILDER
            printf("(13) variable_declaration -> 'ID' indices 'ID' '=' expr\n");
            #endif
            reduce_to_vardecl_w_ind_n_expr(top);
            #if TREEBUILDER
            print_VarDecl(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 14:
            #if DEBUG || TREEBUILDER
            printf("(14) variable_declaration -> 'ID' 'ID'\n");
            #endif
            reduce_to_vardecl(top);
            #if TREEBUILDER
            print_VarDecl(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 15:
            #if DEBUG || TREEBUILDER
            printf("(15) variable_declaration -> 'ID' 'ID' '=' expr\n");
            #endif
            reduce_to_vardecl_w_expr(top);
            #if TREEBUILDER
            print_VarDecl(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 16:
            #if DEBUG || TREEBUILDER
            printf("(16) function_declaration -> 'DEFINE' 'ID' empty_indices 'ID' '(' params ')' '{' compound_statement '}'\n");
            #endif
            reduce_to_func_decl_w_ind_n_params(top);
            #if TREEBUILDER
            print_FuncDecl(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 17:
            #if DEBUG || TREEBUILDER
            printf("(17) function_declaration -> 'DEFINE' 'ID' empty_indices 'ID' '(' ')' '{' compound_statement '}'\n");
            #endif
            reduce_to_func_decl_w_ind(top);
            #if TREEBUILDER
            print_FuncDecl(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 18:
            #if DEBUG || TREEBUILDER
            printf("(18) function_declaration -> 'DEFINE' 'ID' 'ID' '(' params ')' '{' compound_statement '}'\n");
            #endif
            reduce_to_func_decl_w_params(top);
            #if TREEBUILDER
            print_FuncDecl(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 19:
            #if DEBUG || TREEBUILDER
            printf("(19) function_declaration -> 'DEFINE' 'ID' 'ID' '(' ')' '{' compound_statement '}'\n");
            #endif
            reduce_to_func_decl(top);
            #if TREEBUILDER
            print_FuncDecl(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 20:
            #if DEBUG || TREEBUILDER
            printf("(20) empty_indices -> empty_indices '[' ']'\n");
            #endif
            reduce_to_empty_ind_list(top);
            break;

        case 21:
            #if DEBUG || TREEBUILDER
            printf("(21) empty_indices -> '[' ']'\n");
            #endif
            reduce_to_empty_ind(top);
            break;

        case 22:
            #if DEBUG || TREEBUILDER
            printf("(22) params -> params ',' variable_declaration\n");
            #endif
            reduce_to_param_list(top);
            break;

        case 23:
            #if DEBUG || TREEBUILDER
            printf("(23) params -> variable_declaration\n");
            #endif
            reduce_to_param(top);
            break;

        case 24:
            #if DEBUG || TREEBUILDER
            printf("(24) indices -> indices '[' expr ']'\n");
            #endif
            reduce_to_ind_list_w_expr(top);
            break;

        case 25:
            #if DEBUG || TREEBUILDER
            printf("(25) indices -> '[' expr ']'\n");
            #endif
            reduce_to_ind_w_expr(top);
            break;

        case 26:
            #if DEBUG || TREEBUILDER
            printf("(26) indices -> indices '[' ']'\n");
            #endif
            reduce_to_ind_list(top);
            break;

        case 27:
            #if DEBUG || TREEBUILDER
            printf("(27) indices -> '[' ']'\n");
            #endif
            reduce_to_ind(top);
            break;

        case 28:
            #if DEBUG || TREEBUILDER
            printf("(28) variable_access -> 'ID'\n");
            #endif
            reduce_to_varacc(top);
            #if TREEBUILDER
            print_VarAcc(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 29:
            #if DEBUG || TREEBUILDER
            printf("(29) variable_access -> 'ID' indices\n");
            #endif
            reduce_to_varacc_w_ind(top);
            #if TREEBUILDER
            print_VarAcc(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 30:
            #if DEBUG || TREEBUILDER
            printf("(30) expr -> expr '-' expr\n");
            #endif
            reduce_to_expr_binop(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 31:
            #if DEBUG || TREEBUILDER
            printf("(31) expr -> expr '+' expr\n");
            #endif
            reduce_to_expr_binop(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 32:
            #if DEBUG || TREEBUILDER
            printf("(32) expr -> expr '/' expr\n");
            #endif
            reduce_to_expr_binop(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 33:
            #if DEBUG || TREEBUILDER
            printf("(33) expr -> expr '%%' expr\n");
            #endif
            reduce_to_expr_binop(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 34:
            #if DEBUG || TREEBUILDER
            printf("(34) expr -> expr '*' expr\n");
            #endif
            reduce_to_expr_binop(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 35:
            #if DEBUG || TREEBUILDER
            printf("(35) expr -> expr '^' expr\n");
            #endif
            reduce_to_expr_binop(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 36:
            #if DEBUG || TREEBUILDER
            printf("(36) expr -> '(' expr ')'\n");
            #endif
            reduce_to_expr_paren(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 37:
            #if DEBUG || TREEBUILDER
            printf("(37) expr -> 'ICONST'\n");
            #endif
            reduce_to_expr_const(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 38:
            #if DEBUG || TREEBUILDER
            printf("(38) expr -> 'FCONST'\n");
            #endif
            reduce_to_expr_const(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 39:
            #if DEBUG || TREEBUILDER
            printf("(39) expr -> 'SCONST'\n");
            #endif
            reduce_to_expr_const(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 40:
            #if DEBUG || TREEBUILDER
            printf("(40) expr -> variable_access\n");
            #endif
            reduce_to_expr_varacc(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 41:
            #if DEBUG || TREEBUILDER
            printf("(41) expr -> function_call\n");
            #endif
            reduce_to_expr_funccall(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 42:
            #if DEBUG || TREEBUILDER
            printf("(42) expr -> '+' expr\n");
            #endif
            reduce_to_expr_unary(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 43:
            #if DEBUG || TREEBUILDER
            printf("(43) expr -> '-' expr\n");
            #endif
            reduce_to_expr_unary(top);
            #if TREEBUILDER
            print_Expr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 44:
            #if DEBUG || TREEBUILDER
            printf("(44) assignment_statement -> variable_access 'ASSIGN' expr\n");
            #endif
            reduce_to_assign(top);
            #if TREEBUILDER
            print_AStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 45:
            #if DEBUG || TREEBUILDER
            printf("(45) assignment_statement -> variable_access '=' expr\n");
            #endif
            reduce_to_assign(top);
            #if TREEBUILDER
            print_AStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 46:
            #if DEBUG || TREEBUILDER
            printf("(46) assignment_statement -> variable_access 'SUFFIXOP'\n");
            #endif
            reduce_to_assign_suffixop(top);
            #if TREEBUILDER
            print_AStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 47:
            #if DEBUG || TREEBUILDER
            printf("(47) function_call -> 'ID' '(' args ')'\n");
            #endif
            reduce_to_funccall_w_args(top);
            #if TREEBUILDER
            print_FuncCall(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 48:
            #if DEBUG || TREEBUILDER
            printf("(48) function_call -> 'ID' '(' ')'\n");
            #endif
            reduce_to_funccall(top);
            #if TREEBUILDER
            print_FuncCall(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 49:
            #if DEBUG || TREEBUILDER
            printf("(49) args -> args ',' expr\n");
            #endif
            reduce_to_args_args(top);
            break;

        case 50:
            #if DEBUG || TREEBUILDER
            printf("(50) args -> expr\n");
            #endif
            reduce_to_args_expr(top);
            break;

        case 51:
            #if DEBUG || TREEBUILDER
            printf("(51) if_elif_else_statement -> if_statement\n");
            #endif
            reduce_to_ieestmt_ifstmt(top);
            #if TREEBUILDER
            print_IEEStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 52:
            #if DEBUG || TREEBUILDER
            printf("(52) if_elif_else_statement -> if_statement elif_list\n");
            #endif
            reduce_to_ieestmt_eliflist(top);
            #if TREEBUILDER
            print_IEEStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 53:
            #if DEBUG || TREEBUILDER
            printf("(53) elif_list -> elif_statement elif_list\n");
            #endif
            reduce_to_eliflist_eliflist(top);
            break;

        case 54:
            #if DEBUG || TREEBUILDER
            printf("(54) elif_list -> elif_statement\n");
            #endif
            reduce_to_eliflist_elif(top);
            break;

        case 55:
            #if DEBUG || TREEBUILDER
            printf("(55) elif_list -> else_statement\n");
            #endif
            reduce_to_eliflist_else(top);
            break;

        case 56:
            #if DEBUG || TREEBUILDER
            printf("(56) if_statement -> 'IF' b_expr '{' compound_statement '}'\n");
            #endif
            reduce_to_cond(top);
            #if TREEBUILDER
            print_CondStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 57:
            #if DEBUG || TREEBUILDER
            printf("(57) elif_statement -> 'ELIF' b_expr '{' compound_statement '}'\n");
            #endif
            reduce_to_cond(top);
            #if TREEBUILDER
            print_CondStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 58:
            #if DEBUG || TREEBUILDER
            printf("(58) else_statement -> 'ELSE' '{' compound_statement '}'\n");
            #endif
            reduce_to_else(top);
            #if TREEBUILDER
            print_CompStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 59:
            #if DEBUG || TREEBUILDER
            printf("(59) while_loop -> 'WHILE' b_expr '{' compound_statement '}'\n");
            #endif
            reduce_to_cond(top);
            #if TREEBUILDER
            print_WLoop(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 60:
            #if DEBUG || TREEBUILDER
            printf("(60) for_loop -> 'FOR' variable_declaration ',' b_expr ',' assignment_statement '{' compound_statement '}'\n");
            #endif
            reduce_to_for_vardecl(top);
            #if TREEBUILDER
            print_FLoop(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 61:
            #if DEBUG || TREEBUILDER
            printf("(61) for_loop -> 'FOR' assignment_statement ',' b_expr ',' assignment_statement '{' compound_statement '}'\n");
            #endif
            reduce_to_for_assign(top);
            #if TREEBUILDER
            print_FLoop(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 62:
            #if DEBUG || TREEBUILDER
            printf("(62) b_expr -> b_expr 'NAND' b_expr\n");
            #endif
            reduce_to_bexpr_binop(top);
            #if TREEBUILDER
            print_BExpr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 63:
            #if DEBUG || TREEBUILDER
            printf("(63) b_expr -> '(' b_expr 'NAND' b_expr ')'\n");
            #endif
            reduce_to_bexpr_binop_w_paren(top);
            #if TREEBUILDER
            print_BExpr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 64:
            #if DEBUG || TREEBUILDER
            printf("(64) b_expr -> r_expr\n");
            #endif
            reduce_to_b_expr_r_expr(top);
            #if TREEBUILDER
            print_BExpr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 65:
            #if DEBUG || TREEBUILDER
            printf("(65) b_expr -> '(' b_expr ')'\n");
            #endif
            reduce_to_bexpr_bexpr_w_paren(top);
            #if TREEBUILDER
            print_BExpr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 66:
            #if DEBUG || TREEBUILDER
            printf("(66) r_expr -> expr 'RELOP' expr\n");
            #endif
            reduce_to_rexpr_binop(top);
            #if TREEBUILDER
            print_RExpr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 67:
            #if DEBUG || TREEBUILDER
            printf("(67) r_expr -> expr\n");
            #endif
            reduce_to_rexpr_expr(top);
            #if TREEBUILDER
            print_RExpr(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 68:
            #if DEBUG || TREEBUILDER
            printf("(68) scope -> '{' compound_statement '}'\n");
            #endif
            reduce_to_scope(top);
            #if TREEBUILDER
            print_CompStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;

        case 69:
            #if DEBUG || TREEBUILDER
            printf("(69) return_statement -> 'RETURN' expr\n");
            #endif
            reduce_to_return(top);
            #if TREEBUILDER
            print_ReturnStmt(**top, 0, 1, 1);
            printf("\n");
            printf("----------------------------------------------------------\n");
            printf("\n");
            #endif
            break;
        default:
            printf("Something went wrong\n\n");
            exit(-1);
    }
}

/*
 * Reduction case functions.
 */

//case 1
static inline void reduce_to_compound_compound_list(void*** top)
{
    struct CompStmt* node = malloc(sizeof(struct CompStmt));
    struct Stmt* tmp_stmt = **top;
    (*top)--;

    struct CompStmt* prior_compound = **top;

    int n_new_stmts = prior_compound->n_statements+1;
    node->n_statements = n_new_stmts;
    node->statement_list = malloc(sizeof(struct Stmt*)*n_new_stmts);
    node->statement_list[n_new_stmts-1] = tmp_stmt;
    memcpy(node->statement_list, prior_compound->statement_list,
            sizeof(struct Stmt*)*(n_new_stmts-1));
    free(prior_compound->statement_list);
    free(prior_compound);
    **top = node;
}

//case 2
static inline void reduce_to_compound_statement(void*** top)
{
    struct CompStmt* node = malloc(sizeof(struct CompStmt));
    node->n_statements = 1;
    node->statement_list = malloc(sizeof(struct Stmt*));
    node->statement_list[0] = **top;
    **top = node;
}

//case 3
static inline void reduce_to_stmt_vardecl(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    free_token(**top);
    (*top)--;
    node->statement_type = VARIABLE_DECLARATION;
    node->stmt = **top;
    **top = node;
}

//case 4
static inline void reduce_to_stmt_funcdecl_(void*** top)
{
    #if DEBUG
    printf("statement -> function_declaration");
    #endif
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->statement_type = FUNCTION_DECLARATION;
    node->stmt = **top;
    **top = node;
    return_found = FALSE;
}

//case 5
static inline void reduce_to_stmt_assignment_statement(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    free_token(**top);
    (*top)--;
    node->statement_type = ASSIGNMENT_STATEMENT;
    node->stmt = **top;
    **top = node;
}

//case 6
static inline void reduce_to_stmt_funccall(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    free_token(**top);
    (*top)--;
    node->statement_type = FUNCTION_CALL;
    node->stmt = **top;
    **top = node;
}

//case 7
static inline void reduce_to_stmt_ieestmt(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->statement_type = IF_ELIF_ELSE_STATEMENT;
    node->stmt = **top;
    **top = node;
}

//case 8
static inline void reduce_to_stmt_wloop(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->statement_type = WHILE_LOOP;
    node->stmt = **top;
    **top = node;
}
// case 9
static inline void reduce_to_stmt_floop(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->statement_type = FOR_LOOP;
    node->stmt = **top;
    **top = node;
}

//case 10
static inline void reduce_to_stmt_scope(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    node->statement_type = SCOPE;
    node->stmt = **top;
    **top = node;
}
//case 11
static inline void reduce_to_stmt_return(void*** top)
{
    struct Stmt* node = malloc(sizeof(struct Stmt));
    free(**top);
    (*top)--;
    // Hmmm....
    node->statement_type = RETURN_STATEMENT;
    node->stmt = **top;
    **top = node;
    return_found = TRUE;
}
//case 12
static inline void reduce_to_vardecl_w_ind(void*** top)
{
    struct VarDecl* node = malloc(sizeof(struct VarDecl));
    node->name = **top;
    node->expr = NULL;
    (*top)--;
    struct Inds* ind = **top;
    int n_indices = ind->n_indices;
    node->n_indices = n_indices;
    node->indices = malloc(sizeof(struct Expr*)*n_indices);
    memcpy(node->indices, ind->indices, sizeof(struct Expr*)*n_indices);
    free(ind->indices);
    free(ind);
    (*top)--;
    node->type = **top;
    **top = node;
}

//case 13
static inline void reduce_to_vardecl_w_ind_n_expr(void*** top)
{
    struct VarDecl* node = malloc(sizeof(struct VarDecl));
    node->expr = **top;
    (*top)--;

    free(*top);
    (*top)--;

    node->name = **top;
    (*top)--;

    struct Inds* ind = **top;
    int n_indices = ind->n_indices;
    node->n_indices = n_indices;
    node->indices = malloc(sizeof(struct Expr*)*n_indices);
    memcpy(node->indices, ind->indices, sizeof(struct Expr*)*n_indices);
    free(ind->indices);
    free(ind);
    (*top)--;

    node->type = **top;
    **top = node;
}

//case 14
static inline void reduce_to_vardecl(void*** top)
{
    struct VarDecl* node = malloc(sizeof(struct VarDecl));
    node->n_indices = 0;
    node->indices = NULL;
    node->expr = NULL;

    node->name = **top;
    (*top)--;

    node->type = **top;

    **top = node;
}

//case 15
static inline void reduce_to_vardecl_w_expr(void*** top)
{
    struct VarDecl* node = malloc(sizeof(struct VarDecl));
    node->n_indices = 0;
    node->indices = NULL;

    node->expr = **top;
    (*top)--;
    free_token(**top);
    (*top)--;
    node->name = **top;
    (*top)--;

    node->type = **top;
    **top = node;
}

//case 16
static inline void reduce_to_func_decl_w_ind_n_params(void*** top)
{
    struct FuncDecl* node = malloc(sizeof(struct FuncDecl));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Params* params = **top;
    int n_params = params->n_params;
    node->n_params = n_params;
    node->params = malloc(sizeof(struct VarDecl*)*n_params);
    memcpy(node->params, params->params, sizeof(struct VarDecl*)*n_params);
    free(params->params);
    free(params);
    (*top)--;

    free_token(**top);
    (*top)--;

    int* n_empty = **top;
    node->n_indices = *n_empty;
    free(n_empty);
    (*top)--;

    node->name = **top;;
    (*top)--;

    free_token(**top);

    **top = node;
}

//case 17
static inline void reduce_to_func_decl_w_ind(void*** top)
{
    struct FuncDecl* node = malloc(sizeof(struct FuncDecl));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    node->n_params = 0;
    node->params = NULL;

    free_token(**top);
    (*top)--;

    int* n_empty = **top;
    node->n_indices = *n_empty;
    free(n_empty);
    (*top)--;

    node->name = **top;
    (*top)--;

    free_token(**top);

    **top = node;
}

//case 18
static inline void reduce_to_func_decl_w_params(void*** top)
{
    struct FuncDecl* node = malloc(sizeof(struct FuncDecl));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Params* params = **top;
    int n_params = params->n_params;
    node->n_params = n_params;
    node->params = malloc(sizeof(struct VarDecl*)*n_params);
    memcpy(node->params, params->params, sizeof(struct VarDecl*)*n_params);
    free(params->params);
    free(params);
    (*top)--;


    free_token(**top);

    (*top)--;

    node->n_indices = 0;

    node->name = **top;;
    (*top)--;

    node->type = **top;
    (*top)--;

    free_token(**top);

    **top = node;
}

//case 19
static inline void reduce_to_func_decl(void*** top)
{
    struct FuncDecl* node = malloc(sizeof(struct FuncDecl));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    node->n_params = 0;
    node->params = NULL;

    free_token(**top);
    (*top)--;

    node->n_indices = 0;

    node->name = **top;
    (*top)--;

    free_token(**top);

    **top = node;
}

//case 20
static inline void reduce_to_empty_ind_list(void*** top)
{
    int* node;
    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    node = **top;
    (*node)++;

    **top = node;
}
//20
static inline void reduce_to_empty_ind(void*** top)
{
    int* node = malloc(sizeof(int));

    free_token(**top);
    (*top)--;
    free_token(**top);

    (*node) = 1;

    **top = node;
}

//case 22
static inline void reduce_to_param_list(void*** top)
{
    struct Params* node = malloc(sizeof(struct Params));

    struct VarDecl* next_decl = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Params* prior_params = **top;
    int n_params = prior_params->n_params;
    node->n_params = n_params+1;
    node->params = malloc(sizeof(struct VarDecl*)*(n_params+1));
    node->params[n_params] = next_decl;
    memcpy(node->params, prior_params->params, sizeof(struct Vardecl*)*n_params);
    free(prior_params->params);
    free(prior_params);

    **top = node;
}

//case 23
static inline void reduce_to_param(void*** top)
{
    struct Params* node = malloc(sizeof(struct Params));

    struct VarDecl* next_decl = **top;

    node->n_params = 1;
    node->params = malloc(sizeof(struct VarDecl*));
    node->params[0] = next_decl;

    **top = node;
}

//case 24
static inline void reduce_to_ind_list_w_expr(void*** top)
{
    struct Inds* node = malloc(sizeof(struct Inds));

    free_token(**top);
    (*top)--;

    struct Expr* expr = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Inds* prior_node = **top;
    int n_expr = prior_node->n_indices;
    node->n_indices = n_expr+1;
    node->indices = malloc(sizeof(struct Expr*)*(n_expr+1));
    node->indices[n_expr] = expr;
    memcpy(node->indices, prior_node->indices, sizeof(struct Expr*)*n_expr);
    free(prior_node->indices);
    free(prior_node);

    **top = node;
}

//24
static inline void reduce_to_ind_w_expr(void*** top)
{
    struct Inds* node = malloc(sizeof(struct Inds));

    free_token(**top);
    (*top)--;

    struct Expr* expr = **top;
    (*top)--;

    free_token(**top);

    node->n_indices = 1;
    node->indices = malloc(sizeof(struct Expr*));
    node->indices[0] = expr;

    **top = node;
}
//25
static inline void reduce_to_ind_list(void*** top)
{
    struct Inds* node = malloc(sizeof(struct Inds));

    free_token(**top);
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Inds* prior_node = **top;
    int n_expr = prior_node->n_indices;
    node->n_indices = n_expr+1;
    node->indices = malloc(sizeof(struct Expr*)*(n_expr+1));
    node->indices[n_expr] = NULL;
    memcpy(node->indices, prior_node->indices, sizeof(struct Expr*)*n_expr);
    free(prior_node->indices);
    free(prior_node);

    **top = node;
}

//case 27
static inline void reduce_to_ind(void*** top)
{
    struct Inds* node = malloc(sizeof(struct Inds));

    free_token(**top);
    (*top)--;

    free_token(**top);

    node->n_indices = 1;
    node->indices = malloc(sizeof(struct Expr*));
    node->indices[0] = NULL;

    **top = node;
}

//case 28
static inline void reduce_to_varacc(void*** top)
{
    struct VarAcc* node = malloc(sizeof(struct VarAcc));
    node->n_indices = 0;
    node->indices = NULL;
    node->variable = **top;

    **top = node;
}

//case 29
static inline void reduce_to_varacc_w_ind(void*** top)
{
    struct VarAcc* node = malloc(sizeof(struct VarAcc));
    struct Inds* ind = **top;
    int n_indices = ind->n_indices;
    node->n_indices = n_indices;
    node->indices = malloc(sizeof(struct Expr*)*n_indices);
    memcpy(node->indices, ind->indices, sizeof(struct Expr*)*n_indices);
    free(ind->indices);
    free(ind);
    (*top)--;

    node->variable = **top;

    **top = node;
}

//case 30, 31, 32, 33, 34, 35
static inline void reduce_to_expr_binop(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = BINOP;

    node->right = **top;
    (*top)--;

    node->binary_op = **top;
    (*top)--;

    node->left = **top;

    **top = node;
}

//case 36
static inline void reduce_to_expr_paren(void*** top)
{
    free_token(**top);
    (*top)--;
    /*
     * Since paranthesis are only for precedence,
     * we can put the expression back on the stack
     * without allocating more memory
     */
    struct Expr* node = **top;
    (*top)--;
    free_token(**top);
    **top = node;
}

//case 37, 38, 39
static inline void reduce_to_expr_const(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = CONST;
    node->val = **top;
    **top = node;
}

//case 40
static inline void reduce_to_expr_varacc(void*** top) {
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = VARACC;
    node->variable_access = **top;
    **top = node;
}

//case 41
static inline void reduce_to_expr_funccall(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = FUNCCALL;
    node->function_call = **top;
    **top = node;
}

//case 42, 43
static inline void reduce_to_expr_unary(void*** top)
{
    struct Expr* node = malloc(sizeof(struct Expr));
    node->type = UOP;

    node->unary_op = **top;
    (*top)--;

    node->expr = **top;

    **top = node;
}

//case 44, 45
static inline void reduce_to_assign(void*** top)
{
    struct AStmt* node = malloc(sizeof(struct AStmt));
    node->expr = **top;
    (*top)--;
    node->assignment_type = **top;
    (*top)--;
    node->variable_access = **top;

    **top = node;
}

//case 46
static inline void reduce_to_assign_suffixop(void*** top)
{
    struct AStmt* node = malloc(sizeof(struct AStmt));
    node->assignment_type = **top;
    node->expr = NULL;
    (*top)--;
    node->variable_access = **top;
    **top = node;
}

//case 47
static inline void reduce_to_funccall_w_args(void*** top)
{
    struct FuncCall* node = malloc(sizeof(struct FuncCall));
    free_token(**top);
    (*top)--;

    struct Args* prior_args = **top;
    int n_args = prior_args->n_args;
    node->n_args = n_args;
    node->args = malloc(sizeof(struct Expr*)*n_args);
    memcpy(node->args, prior_args->args, sizeof(struct Expr*)*n_args);
    free(prior_args->args);
    free(prior_args);
    (*top)--;

    free_token(**top);
    (*top)--;


    node->func = **top;
    **top = node;
}

//case 48
static inline void reduce_to_funccall(void*** top)
{
    struct FuncCall* node = malloc(sizeof(struct FuncCall));
    free_token(**top);
    (*top)--;

    node->n_args = 0;
    node->args = NULL;

    free_token(**top);
    (*top)--;

    node->func = **top;
    **top = node;
}

//case 49
static inline void reduce_to_args_args(void*** top)
{
    struct Args* node = malloc(sizeof(struct Args));
    struct Expr* next_arg = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    struct Args* prior_args = **top;
    int n_args = prior_args->n_args;
    node->n_args = n_args+1;
    node->args = malloc(sizeof(struct Expr*)*(n_args+1));
    node->args[n_args] = next_arg;
    memcpy(node->args, prior_args->args, sizeof(struct Expr*)*n_args);
    free(prior_args->args);
    free(prior_args);

    **top = node;
}

//case 50
static inline void reduce_to_args_expr(void*** top)
{
    struct Args* node = malloc(sizeof(struct Args));
    node->n_args = 1;
    node->args = malloc(sizeof(struct Expr*));
    node->args[0] = **top;

    **top = node;
}

//case 51
static inline void reduce_to_ieestmt_ifstmt(void*** top)
{
    struct IEEStmt* node = malloc(sizeof(struct IEEStmt));
    node->n_elifs = 0;
    node->elif_list = NULL;
    node->_else = NULL;
    node->if_stmt = **top;

    **top = node;
}

//case 52
static inline void reduce_to_ieestmt_eliflist(void*** top)
{
    struct IEEStmt* node = malloc(sizeof(struct IEEStmt));
    struct EList* elif_list = **top;

    int n_elifs = elif_list->n_elifs;

    node->n_elifs = n_elifs;
    node->_else = elif_list->_else;

    if (n_elifs) {
        node->elif_list = malloc(sizeof(struct CondStmt*)*n_elifs);
        memcpy(node->elif_list, elif_list->elif_list, sizeof(struct CondStmt*)*n_elifs);
        free(elif_list->elif_list);
    } else {
        node->elif_list = NULL;
    }
    free(elif_list);
    (*top)--;

    node->if_stmt = **top;

    **top = node;
}

//case 53
static inline void reduce_to_eliflist_eliflist(void*** top)
{
    struct EList* node = malloc(sizeof(struct EList));
    struct EList* prior_list = **top;
    (*top)--;
    int n_elifs = prior_list->n_elifs;
    if (n_elifs != 0) {
        node->n_elifs = n_elifs+1;
        node->elif_list = malloc(sizeof(struct CondStmt*)*(n_elifs+1));
        memcpy(node->elif_list+1, prior_list->elif_list, sizeof(struct CondStmt*)*n_elifs);
        free(prior_list->elif_list);
    } else {
        node->n_elifs = 1;
        node->elif_list = malloc(sizeof(struct CondStmt*));
    }

    node->_else = prior_list->_else;
    free(prior_list);

    node->elif_list[0] = **top;
    **top = node;
}

//case 54
static inline void reduce_to_eliflist_elif(void*** top)
{
    struct EList* node = malloc(sizeof(struct EList));
    node->n_elifs = 1;
    node->elif_list = malloc(sizeof(struct CondStmt*));
    node->elif_list[0] = **top;
    node->_else = NULL;

    **top = node;
}

//case 55
static inline void reduce_to_eliflist_else(void*** top)
{
    struct EList* node = malloc(sizeof(struct EList));
    node->n_elifs = 0;
    node->elif_list = NULL;
    node->_else = **top;

    **top = node;
}

//case 56, 57, 59
static inline void reduce_to_cond(void*** top)
{
    struct CondStmt* node = malloc(sizeof(struct CondStmt));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->boolean = **top;
    (*top)--;

    free_token(**top);

    **top = node;
}

//case 58
static inline void reduce_to_else(void*** top)
{
    /*
     * Similiar to a paranthesized expressions, the memory for an else is
     * already allocated by compoun statement functions
     */
    struct CompStmt* node;
    free_token(**top);
    (*top)--;

    node = **top;
    (*top)--;

    free_token(**top);
    (*top)--;
    free_token(**top);

    **top = node;
}

//case 60
static inline void reduce_to_for_vardecl(void*** top)
{
    struct FLoop* node = malloc(sizeof(struct FLoop));
    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;
    free_token(**top);
    (*top)--;
    node->update_statement = **top;
    (*top)--;
    free_token(**top);
    (*top)--;

    node->boolean = **top;
    (*top)--;
    free_token(**top);
    (*top)--;

    node->type = VARIABLE_DECLARATION;
    node->init_stmt = **top;
    (*top)--;
    free_token(**top);

    **top = node;
}

//case 61
static inline void reduce_to_for_assign(void*** top)
{
    struct FLoop* node = malloc(sizeof(struct FLoop));

    free_token(**top);
    (*top)--;

    node->body = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->update_statement = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->boolean = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->type = ASSIGNMENT_STATEMENT;
    node->init_stmt = **top;

    (*top)--;

    free_token(**top);

    **top = node;
}

//case 62
static inline void reduce_to_bexpr_binop(void*** top)
{
    struct BExpr* node = malloc(sizeof(struct BExpr));
    node->type = BINOP;
    node->right = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->left = **top;

    **top = node;
}

//case 63
static inline void reduce_to_bexpr_binop_w_paren(void*** top)
{
    struct BExpr* node = malloc(sizeof(struct BExpr));
    node->type = BINOP;
    free_token(**top);
    (*top)--;

    node->right = **top;
    (*top)--;

    free_token(**top);
    (*top)--;

    node->left = **top;
    (*top)--;

    free_token(**top);

    **top = node;
}

//case 64
static inline void reduce_to_b_expr_r_expr(void*** top)
{
    struct BExpr* node = malloc(sizeof(struct BExpr));
    node->type = CONST;
    node->r_expr = **top;

    **top = node;
}

//case 65
static inline void reduce_to_bexpr_bexpr_w_paren(void*** top)
{
    free_token(**top);
    (*top)--;

    struct BExpr* node = **top;
    (*top)--;

    free_token(**top);

    **top = node;
}

//case 66
static inline void reduce_to_rexpr_binop(void*** top)
{
    struct RExpr* node = malloc(sizeof(struct RExpr));
    node->type = BINOP;

    node->right = **top;
    (*top)--;

    node->operator = **top;
    (*top)--;

    node->left = **top;

    **top = node;
}

//case 67
static inline void reduce_to_rexpr_expr(void*** top)
{
    struct RExpr* node = malloc(sizeof(struct RExpr));
    node->type = CONST;
    node->expr = **top;
    **top = node;
}

//case 68
static inline void reduce_to_scope(void*** top)
{
    free_token(**top);
    (*top)--;

    struct CompStmt* node = **top;
    (*top)--;

    free_token(**top);

    **top = node;
}

// case 69
static inline void reduce_to_return(void*** top)
{
    struct Expr* node;
    node = **top;
    (*top)--;

    free_token(**top);
    **top = node;
}

/*
 * Print functions. There are some cryptic parameters...
 */

static inline void write_indent(int nest_level)
{
    for (int i = 0; i < nest_level; i++)
        printf("    ");
}

void print_CompStmt(struct CompStmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("CompStmt\n");
    for (int i = 0; i < node->n_statements; i++) {
        print_Stmt(node->statement_list[i], nest_level+1, labels, leaf);
    }
}

void print_Stmt(struct Stmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("Stmt\n");
    switch (node->statement_type) {
        case VARIABLE_DECLARATION:
            print_VarDecl(node->stmt, nest_level+1, labels, leaf);
            return;
        case FUNCTION_DECLARATION:
            print_FuncDecl(node->stmt, nest_level+1, labels, leaf);
            return;
        case ASSIGNMENT_STATEMENT:
            print_AStmt(node->stmt, nest_level+1, labels, leaf);
            return;
        case FUNCTION_CALL:
            print_FuncCall(node->stmt, nest_level+1, labels, leaf);
            return;
        case IF_ELIF_ELSE_STATEMENT:
            print_IEEStmt(node->stmt, nest_level+1, labels, leaf);
            return;
        case WHILE_LOOP:
            print_WLoop(node->stmt, nest_level+1, labels, leaf);
            return;
        case FOR_LOOP:
            print_FLoop(node->stmt, nest_level+1, labels, leaf);
            return;
        case SCOPE:
            print_CompStmt(node->stmt, nest_level+1, labels, leaf);
            return;
        case RETURN_STATEMENT:
            print_ReturnStmt(node->stmt, nest_level+1, labels, leaf);
        default:
            break;
    }
}

void print_VarDecl(struct VarDecl* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    if (labels) {
        printf("VarDecl");
        if (node->indices) {
            printf(" %dd", node->n_indices);
        }
        if (node->expr != NULL) {
            printf(" = expr\n");
        } else {
            printf("\n");
        }
    } else {
        printf("decl: ");
        print_token_str(node->name);
        printf(" of type ");
        print_token_str(node->type);
        printf("\n");
        for (int i = 0; i < node->n_indices; i++) {
            write_indent(nest_level);
            printf("[\n");
            print_Expr(node->indices[i], nest_level+1, labels, leaf);
            write_indent(nest_level);
            printf("]\n");
        }
    }
}

void print_FuncDecl(struct FuncDecl* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    if (labels) {
        printf("FuncDecl");
        if (node->n_indices) {
            printf(" %dd", node->n_indices);
        }
        printf(" %d params\n", node->n_params);
        print_CompStmt(node->body, nest_level+1, labels, leaf);
    } else {
        printf("func: ");
        print_token_str(node->name);
        printf(" of type ");
        print_token_str(node->type);
        printf(" %dd\n", node->n_indices);
        for (int i = 0; i < node->n_params; i++) {
            write_indent(nest_level);
            printf("\n");
            print_VarDecl(node->params[i], nest_level+1, labels, leaf);
            write_indent(nest_level);
            printf("\n");
        }
        write_indent(nest_level);
        printf(") {");
        print_CompStmt(node->body, nest_level+1, labels, leaf);
    }
}

void print_VarAcc(struct VarAcc* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    if (leaf) {
        printf("Acc");
        print_token_str(node->variable);
        printf("\n");
        for (int i = 0; i < node->n_indices; i++)
            printf("[]");
        printf("\n");
    } else if (labels) {
        print_token_str(node->variable);
        for (int i = 0; i < node->n_indices; i++)
            printf("[]");
        printf("\n");
    }
    else {
        print_token_str(node->variable);
        for (int i = 0; i < node->n_indices; i++) {
            printf("\n");
            write_indent(nest_level);
            printf("[\n");
            print_Expr(node->indices[i], nest_level+1, labels, leaf);
            write_indent(nest_level);
            printf("]\n");
        }
    }
}

void print_Expr(struct Expr* node, int nest_level, char labels, char leaf)
{
    if (leaf) {
        switch (node->type) {
            case BINOP:
                print_Expr(node->left, nest_level+1, labels, leaf);
                write_indent(nest_level);
                print_token_str(node->binary_op);
                printf("\n");
                print_Expr(node->right, nest_level+1, labels, leaf);
                return;
            case UOP:
                write_indent(nest_level);
                print_token_str(node->unary_op);
                printf("\n");
                print_Expr(node->expr, nest_level+1, labels, leaf);
                return;
            case CONST:
                write_indent(nest_level);
                print_token_str(node->val);
                printf("\n");
                return;
            case FUNCCALL:
                write_indent(nest_level);
                print_token_str(node->function_call->func);
                printf("\n");
                return;
            case VARACC:
                write_indent(nest_level);
                print_token_str(node->variable_access->variable);
                printf("\n");
                return;
        }
    } else {
        switch (node->type) {
            case BINOP:
                print_Expr(node->left, nest_level+1, labels, leaf);
                write_indent(nest_level);
                print_token_str(node->binary_op);
                printf("\n");
                print_Expr(node->right, nest_level+1, labels, leaf);
            case UOP:
                write_indent(nest_level);
                print_token_str(node->unary_op);
                printf("\n");
                print_Expr(node->expr, nest_level+1, labels, leaf);
                return;
            case CONST:
                write_indent(nest_level);
                print_token_str(node->val);
                printf("\n");
                return;
            case FUNCCALL:
                print_FuncCall(node->function_call, nest_level, labels, leaf);
                return;
            case VARACC:
                print_VarAcc(node->variable_access, nest_level, labels, leaf);
                return;
        }
    }
}

void print_AStmt(struct AStmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);


    if (leaf) {
        printf("var ");
        if (node->assignment_type->type == SUFFIXOP) {
            print_token_str(node->assignment_type);
            printf("\n");
        }
        else {
            print_token_str(node->assignment_type);
            printf(" expr\n");
        }
    } else if (labels) {
        printf("Assign\n");
    } else {
        printf("Assignment\n");
        print_VarAcc(node->variable_access, nest_level+1, labels, leaf);
        printf("\n");
        write_indent(nest_level);
        printf("by ");
        print_token_str(node->assignment_type);
        printf("\n");
        print_Expr(node->expr, nest_level+1, labels, leaf);
    }
}

void print_FuncCall(struct FuncCall* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    if (labels) {
        printf("FuncCall\n");
    } else {
        printf("Call ");
        print_token_str(node->func);
        printf("with: \n");
        for (int i = 0; i < node->n_args; i++) {
            print_Expr(node->args[i], nest_level+1, labels, leaf);
        }
    }

}

void print_IEEStmt(struct IEEStmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("if:\n");
    print_CondStmt(node->if_stmt, nest_level, labels, leaf);
    for (int i = 0; i < node->n_elifs; i++) {
        write_indent(nest_level);
        printf("elif:\n");
        print_CondStmt(node->elif_list[i], nest_level, labels, leaf);
    }
    if (node->_else != NULL) {
        write_indent(nest_level);
        printf("else:\n");
        print_CompStmt(node->_else, nest_level+1, labels, leaf);
    }
}

void print_CondStmt(struct CondStmt* node, int nest_level, char labels, char leaf)
{
    if (!labels)
        print_BExpr(node->boolean, nest_level+1, labels, leaf);
    print_CompStmt(node->body, nest_level+1, labels, leaf);
}

void print_WLoop(struct CondStmt* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("while\n");
    print_CondStmt(node, nest_level, labels, leaf);
}

void print_FLoop(struct FLoop* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("for:\n");
    if (!labels) {
        if (node->type == VARIABLE_DECLARATION) {
            print_VarDecl(node->init_stmt, nest_level+1, labels, leaf);
        } else {
            print_AStmt(node->init_stmt, nest_level+1, labels, leaf);
        }
        write_indent(nest_level);
        printf(",\n");
        print_BExpr(node->boolean, nest_level+1, labels, leaf);
        write_indent(nest_level);
        printf(",\n");
        print_AStmt(node->update_statement, nest_level+1, labels, leaf);
        printf(",\n");
    }
    print_CompStmt(node->body, nest_level+1, labels, leaf);
}

void print_BExpr(struct BExpr* node, int nest_level, char labels, char leaf)
{
    if (node->type == BINOP) {
        print_BExpr(node->left, nest_level+1, labels, leaf);
        write_indent(nest_level);
        printf("nand\n");
        print_BExpr(node->right, nest_level+1, labels, leaf);
    } else {
        print_RExpr(node->r_expr, nest_level+1, labels, leaf);
    }
}

void print_RExpr(struct RExpr* node, int nest_level, char labels, char leaf)
{
    if (labels) {
        if (node->type == BINOP) {
            write_indent(nest_level);
            printf("expr ");
            print_token_str(node->operator);
            printf(" expr \n");
        } else {
            write_indent(nest_level);
            printf("expr\n");
        }
    } else {
        if (node->type == BINOP) {
            print_Expr(node->left, nest_level+1, labels, leaf);
            write_indent(nest_level);
            print_token_str(node->operator);
            printf("\n");
            print_Expr(node->right, nest_level+1, labels, leaf);
        } else {
            print_Expr(node->expr, nest_level, labels, leaf);
        }
    }

}

void print_ReturnStmt(struct Expr* node, int nest_level, char labels, char leaf)
{
    write_indent(nest_level);
    printf("return\n");
    if (leaf) {
        print_Expr(node, nest_level+1, labels, leaf);
    }
}


/*
 * Tree destruction functions.
 */

void free_CompStmt(struct CompStmt* node)
{
    //printf("FREE COMPOUND\n");
    for (int i = 0; i < node->n_statements; i++) {
        free_Stmt(node->statement_list[i]);
    }
    free(node->statement_list);
    free(node);
}

void free_Stmt(struct Stmt* node)
{
    //printf("FREE STATEMENT\n");
    switch (node->statement_type) {
        case VARIABLE_DECLARATION:
            free_VarDecl(node->stmt);
            break;
        case FUNCTION_DECLARATION:
            free_FuncDecl(node->stmt);
            break;
        case ASSIGNMENT_STATEMENT:
            free_AStmt(node->stmt);
            break;
        case FUNCTION_CALL:
            free_FuncCall(node->stmt);
            break;
        case IF_ELIF_ELSE_STATEMENT:
            free_IEEStmt(node->stmt);
            break;
        case WHILE_LOOP:
            free_CondStmt(node->stmt);
            break;
        case FOR_LOOP:
            free_FLoop(node->stmt);
            break;
        case SCOPE:
            free_CompStmt(node->stmt);
            break;
        case RETURN_STATEMENT:
            free_Expr(node->stmt);
            break;
        default:
            break;
    }
    free(node);
}

void free_VarDecl(struct VarDecl* node)
{
    //printf("FREE VARIABLE DECLARATION\n");
    free_token(node->type);
    if (node->n_indices > 0) {
        for (int i = 0; i < node->n_indices; i++)
            free_Expr(node->indices[i]);

        free(node->indices);
    }
    free_token(node->name);
    if (node->expr != NULL)
        free_Expr(node->expr);
    free(node);
}

void free_FuncDecl(struct FuncDecl* node)
{
    //printf("FREE FUNCTION DECLARATION\n");
    free_token(node->type);
    free_token(node->name);
    for (int i = 0; i < node->n_params; i++)
        free_VarDecl(node->params[i]);
    free(node->params);
    free_CompStmt(node->body);
    free(node);
}

void free_VarAcc(struct VarAcc* node)
{
    //printf("FREE VARIABLE ACCESS\n");
    free_token(node->variable);
    for (int i = 0; i < node->n_indices; i++)
        free_Expr(node->indices[i]);
    free(node->indices);
    free(node);
}

void free_Expr(struct Expr* node)
{
    //printf("FREE EXPR\n");
        switch (node->type) {
        case BINOP:
            free_Expr(node->left);
            free_token(node->binary_op);
            free_Expr(node->right);
            break;
        case UOP:
            free_token(node->unary_op);
            free_Expr(node->expr);
            break;
        case CONST:
            free_token(node->val);
            break;
        case FUNCCALL:
            free_FuncCall(node->function_call);
            break;
        case VARACC:
            free_VarAcc(node->variable_access);
            break;
    }
    free(node);
}

void free_AStmt(struct AStmt* node)
{
    //printf("FREE ASSIGMENT STATEMENT\n");

    free_VarAcc(node->variable_access);
    free_token(node->assignment_type);
    if (node->expr != NULL)
        free_Expr(node->expr);
    free(node);
}

void free_FuncCall(struct FuncCall* node)
{
    //printf("FREE FUNCTION CALL\n");
    free_token(node->func);
    for (int i = 0; i < node->n_args; i++)
        free_Expr(node->args[i]);
    free(node->args);
    free(node);
}

void free_IEEStmt(struct IEEStmt* node)
{
    //printf("FREE IF ELIF ELSE STATEMENT\n");
    free_CondStmt(node->if_stmt);
    if (node->n_elifs > 0) {
        for (int i = 0; i < node->n_elifs; i++)
            free_CondStmt(node->elif_list[i]);
        free(node->elif_list);
    }
    if (node->_else != NULL)
        free_CompStmt(node->_else);
    free(node);
}

void free_CondStmt(struct CondStmt* node)
{
    //printf("FREE CONDITIONAL STATEMENT\n");
    free_BExpr(node->boolean);
    free_CompStmt(node->body);
    free(node);
}

void free_FLoop(struct FLoop* node)
{
    //printf("FREE FOR LOOP\n");
    if (node->type == VARIABLE_DECLARATION)
        free_VarDecl(node->init_stmt);
    else
        free_AStmt(node->init_stmt);
    free_BExpr(node->boolean);
    printf("free update\n");
    free_AStmt(node->update_statement);
    free_CompStmt(node->body);
    free(node);
}

void free_BExpr(struct BExpr* node)
{
    //printf("FREE BOOLEAN EXPR\n");
    if (node->type == BINOP) {
        free_BExpr(node->left);
        free_BExpr(node->right);
    } else {
        free_RExpr(node->r_expr);
    }
    free(node);
}

void free_RExpr(struct RExpr* node)
{
    //printf("FREE RELATIONAL EXPR\n");

    if (node->type == BINOP) {
        free_Expr(node->left);
        free_token(node->operator);
        free_Expr(node->right);
    } else {
        free_Expr(node->expr);
    }
    free(node);
}



int main(int argc, const char** argv)
{
    const char* table_file = "parsing_table.txt";
    filename = argv[1];
    file_desc = open(filename, O_RDONLY);
    init_lexer();
    generate_parse_table(table_file);
    printf("parsing...\n");
    struct CompStmt* tree = lr_parser(1);
    if (return_found)
        return_error();
    close(file_desc);
    SymTab_dump(keywords);
    printf("free tree\n");
    free_CompStmt(tree);
    printf("free table\n");
    destroy_parse_table();
    SymTab_destroy(keywords);


}
