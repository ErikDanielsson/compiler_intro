#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include "lexer.h"
#include "symbol_table.h"
#include "parser.h"
#include "table_generator.h"

#define STACK_SIZE 8192
#define TRUE 1
#define FALSE 0
#define VERBOSE 1
char grammar_error = FALSE;
char recovery_mode = FALSE;
/*
 * Stack machine for LR parsing. Uses a LALR parsing table and generated by
 * "table_generator.c", and produces a parse of the token stream from the lexer.
 */

void lr_parser(char verbose)
/*
 * Uses variables rules, reduction_rules, n_pop_states, action table,
 * n_states, and goto_table defined in "table_generator.h"
 */
{

	#if VERBOSE
	printf("parsing...\n");
	#endif

	int stack[STACK_SIZE];
	int* s_ptr = stack;
	struct Token* a = get_token();
	struct Token* recovery_token = NULL;
	*s_ptr = 0;
	int action;
	parsing_loop:
	while (1) {
		action = action_table[*s_ptr][a->type];
		#if VERBOSE
		printf("Stack depth %ld, top: %d\n", s_ptr-stack, *s_ptr);
		printf("action: %d, lexeme: '%s', %x\n", action, a->lexeme, a->type);
		#endif

		if (action >= n_states) {
			if (a->type == 0x04)
				printf("error in state %d on input 'EOF'\n", *s_ptr);
			else
				printf("error in state %d on input '%s'\n", *s_ptr, a->lexeme);
			#if VERBOSE
			printf("Stack: ");
			for (int i = 0; i <=  s_ptr-stack; i++)
				printf("%d, ", *(stack+i));

			printf("\n");
			#endif
			int* row = action_table[*s_ptr];
			int len;
			if (a->lexeme == NULL)
				len = 0;
			else
				len = strlen(a->lexeme);
			if (row['}'] < n_states) {
				char* msg = malloc(sizeof(char)*(strlen("Expected '}' before ")+strlen(a->lexeme)+3));
				strcpy(msg, "Expected '}' before '");
				strcat(msg, a->lexeme);
				strcat(msg, "'");

				struct Token* tmp = inject_token('}');
				parser_error(len, msg, 0, a->line, a->column, a->column+1, '}');
				free(msg);
				grammar_error = TRUE;
				recovery_token = a;
				a = tmp;
				recovery_mode = TRUE;
				goto parsing_loop;
			} else if (row[';'] < n_states) {
				char* msg = malloc(sizeof(char)*(strlen("Expected ',' before ")+strlen(a->lexeme)+3));
				strcpy(msg, "Expected ';' before '");
				strcat(msg, a->lexeme);
				strcat(msg, "'");
				struct Token* tmp = inject_token(';');
				parser_error(len, msg, 0, a->line, a->column, -1, ';');
				free(msg);
				grammar_error = TRUE;
				recovery_token = a;
				a = tmp;
				recovery_mode = TRUE;

				goto parsing_loop;
			}
			free(a);
			parser_error(len, "", 0, a->line, a->column, 0, 0);
			return;
		} else if (action >= 0) {
			s_ptr++;
			#if VERBOSE
			printf("Push %d\n", action);
			#endif
			*s_ptr = action;
			if (a->lexeme != NULL)
				free(a->lexeme);
			free(a);
			if (recovery_mode) {
				a = recovery_token;
				recovery_mode = FALSE;
			} else {
				a = get_token();
			}

		} else if (action == -1) {
			#if VERBOSE
			printf("parse done\n");
			#endif
			free(a);
			return;
		} else {
			int r = reduction_rules[-(action+1)];
			s_ptr -= n_pop_states[-(action+1)];
			int tmp = *s_ptr;
			s_ptr++;
			*s_ptr = goto_table[r][tmp];
			#if VERBOSE
			printf("reduce by %s\n", rules[-(action+1)]);
			#endif
		}
	}
}

void parser_error(int length, const char* expected,
		  int fatal, int line, int column,
		  int inject_symbol, char symbol) {
	error("syntax error", length, expected, fatal, line, column,
		inject_symbol, symbol);
}

struct Token* inject_token(enum TokenType type) {
	struct Token* imaginary_token = malloc(sizeof(struct Token));
	imaginary_token->type = type;
	imaginary_token->lexeme = NULL;
	return imaginary_token;
}

int main(int argc, const char** argv) {
	const char* table_file = "parsing_table.txt";
	filename = argv[1];
	file_desc = open(filename, O_RDONLY);
	init_lexer();
	generate_parse_table(table_file);
	lr_parser(1);
	destroy_parse_table();
	SymTab_destroy(symbol_table);
	close(file_desc);

}
