Instruction types:
    Assignment:
        if type == float:
            if rval is Temp
                change addr_decs
            if rval is Var
                if rval is not in mem:
                    get new reg and set it to rval
                set all registers in containing rval to also contain lval
            if rval is const
                if rval is in mem:
                    get new reg and set it to rval
                set all registers in containing rval to also contain lval

        if type == int:
            if rval is Temp
                change addr_decs
            if rval is Var
                if rval is not in mem:
                    get new reg and set it to rval
                set all registers in containing rval to also contain lval
            if rval is const
                if there are next uses of lval:
                    get new reg and mov rval into it. set addr_decs
                else
                    mov const directly into lval
    Binop:
        If type == float:
            Add:
            Sub:
            Mul:
            Div:
            Mul:
                if (op1 is Temp)
                    result_reg = op1
                else
                    get free reg for result
                    switch (op1)
                        case var:
                        case const:
                            check if loaded from mem
                            else
                                if there is next use
                                    load to register
                                else
                                    use directly

                    emit instruction("mov result, op1")
                switch (op2)
                    case Temp:
                        use op2 reg
                    case var:
                    case const:
                        check if loaded from mem
                        else
                            if there is next use
                                load to register
                            else
                                use directly
                emit instruction("operator result, op2")

        if type == integer:
            Add:
            Sub:
            And:
            Or:
            Xor:
            Shl:
            Shr:
                if (op1 is Temp)
                    result_reg = op1
                else
                    get free reg for result
                    switch (op1)

                        case var:
                            check if loaded from mem
                            else
                                if there is next use
                                    load to register
                                else
                                    use directly
                        case const:
                            use directly

                    emit instruction("mov result, op1")
                switch (op2)
                    case Temp:
                        use op2 reg
                    case var:
                        check if loaded from mem
                        else
                            if there is next use
                                load to register
                            else
                                use directly
                    case const:
                        use directly
                emit instruction("operator result, op2")
            Div:
            Mod:
                clear rax and rdx
                if they contain temporaries, move these to clean registers.
                If none are available, some stores of variables could be needed.
                Move dividend to rax and extend it to rdx.
                Divide
    Uop:
        if type == integer:
            if (op is Temp)
                result_reg = op
            else
                if (op is Var)
                    if op is loaded from memory
                        if there is no next use of op
                            if op does not resides in itself
                                store(op)
                            result_reg = op
                        else
                            get free reg and move op from reg loc to new reg
                    else
                        get free reg and load op into it.
                else (if op is const)
                    get free reg and load op into it.

            emit instruction("uop result")
        if type == float:
            if (op is Temp)
                result_reg = op
            else
                if (op is Var)
                    if op is loaded from memory
                        if there is no next use of op
                            if op does not resides in itself
                                store(op)
                            result_reg = op
                        else
                            if there are empty regs
                                get free reg and move op from reg loc to new reg
                            else
                                result_reg = op.reg
                    else
                        get free reg and load op into it.
                else if op is const
                    if op is loaded from memory
                        if there are empty regs
                            get free reg and move op from reg loc to new reg
                        else
                            result_reg = op
                    else
                        get free reg and load op into it.

            emit instruction("uop result")
    Conversion:
        switch op
            case temp:
                if float -> float && int -> int
                    emit instruction ("conv op, op");
                if float -> int
                    get int reg
                    emit instruction ("conv new, op");
                if int -> float
                    get float reg
                    emit instruction ("conv new, op");
            case var:
                if float -> float && int -> int
                    if op is loaded from mem:
                        if op has no next use:
                            if op does not resides in itself
                                store(op)
                            emit instruction ("conv op.reg, op.reg")
                        else
                            if there are empty regs
                                get free reg and move op from reg loc to new reg
                            else
                                result_reg = op
                        emit instruction ("conv op, op");
                if float -> int
                    get int reg
                    if op is loaded from mem
                        emit instruction ("conv new, op.reg");
                    else
                        emit instruction ("conv new, [op]");
                if int -> float
                    get float reg
                    if op is loaded from mem
                        emit instruction ("conv new, op.reg");
                    else
                        emit instruction ("conv new, [op]");
            case const:
                if int -> int:
                    get free reg
                    emit instruction("mov reg, op")
                if float -> float:
                    if op is loaded from memory
                        if there are empty regs
                            get free reg and move op from reg loc to new reg
                        else
                            result_reg = op
                    else
                        get free reg and load op into it.
                    emit instruction
                if float -> int || int -> float
                    get new float and int reg
                    load and convert according to conversion type

    Conditional jump:

    Unconditional jump:
