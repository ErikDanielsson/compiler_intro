e := epsilon, unless otherwise indicated

Exercise 4.6.1 : Describe all the viable prefixes for the following grammars:
a) The grammar S -> 0 S 1 | 01 of Exercise 4.2.2(a):
	0*
! b) The grammar S -> SS+ | SS* | a of Exercise 4.2.1.
	All string generated by the language, but without a terminating * or +

! c ) The grammar S -+ S ( S ) | e of Exercise 4.2.2(c).
	All strings with one more opening parenthesis than closing parenthesis

Exercise 4.6.2 : Construct the SLR sets of items for the (augmented) grammar
of Exercise 4.2.1. Compute the GOTO function for these sets of items. Show
the parsing table for this grammar. Is the grammar SLR?

	I0:	S' -> .S
		S -> .SS+
	 	S -> .SS*
		S -> .a

	I1:	a.

	I2:	S -> S.
		S -> S.S+
		S -> S.S*
		S -> .a

	I3:	S -> SS.+
		S -> SS.*


	I4:	S -> SS+.

	I5:	S -> SS*.





	GOTO:
		I0, S = I2:
		I0, a = I1
		I0, + = {} := error
		I0, * = {} := error
		I0, $ = accept


		I2, S = I3
		I2, a = I1

		I3, + = I4
		I3, * = I5

(1) S -> SS+
(2) S -> SS*
(3) S -> a


-----------------------------------
| STATE |     ACTION	    | GOTO |
|	| a  | +  | *  | $  |  S   |
|----------------------------------|
|   0   | s1 |    |    |    |  2   |
|   1   | r3 | r3 | r3 |    |      |
|   2   | s1 |    |    | ac |  3   |
|   3   |    | s4 | s5 |    |      |
|   4   | r1 | r1 | r1 | r1 |      |
|   5   | r2 | r2 | r2 | r2 |      |
------------------------------------





Exercise 4.6.8 : Show the actions of your parsing table from Exercise 4.6.2 on
the input aa*a+.

        ---------------------------------------------------
           |  STACK  | SYMBOLS | INPUT  |      ACTION     |
	 0 | 0       |         | aa*a+$ | shift           |
	 1 | 0 1     | a       |  a*a+$ | reduce S -> a   |
	 2 | 0 2     | S       |  a*a+$ | shift           |
	 3 | 0 2 1   | Sa      |   *a+$ | reduce S -> a   |
	 4 | 0 2 3   | SS      |   *a+$ | shift           |
	 5 | 0 2 3 5 | SS*     |    a+$ | reduce S -> SS* |
	 6 | 0 2     | S       |    a+$ | shift           |
	 7 | 0 2 1   | Sa      |     +$ | reduce S -> a   |
	 8 | 0 2 3   | SS      |     +$ | shift           |
	 9 | 0 2 3 4 | SS+     |      $ | reduce          |
	10 | 0 2     | S       |      $ | accept          |
	---------------------------------------------------


Exercise 4.6.4: For each of the (augmented) grammars of Exercise 4.2.2(a)­-(g):
a) Construct the SLR sets of items and their GOTO function.
b) Indicate any action conflicts in your sets of items.
c) Construct the SLR-parsing table, if one exists.
a)
	S'-> S
	S -> 0S1 | 01
	a)
	I0: {S'-> .S, S -> .0S1, S -> .01}
	I1: {S' -> S.}
	I2: {S -> 0.S1, S -> 0.1}
	I3: {S -> 01.}
	I4: {S -> 0S.1}
	I5: {S -> 0S1.}

	GOTO(I0, 0) = I2
	GOTO(I0, S) = I1

	GOTO(I1, $) = accept

	GOTO(I2, 1) = I3
	GOTO(I2, 0) = I2
	GOTO(I2, S) = I4
	b)
	No conflicts.
	c)
	(1) S -> 0S1
	(2) S -> 01
	------------------------------
	| STATE | ACTION       | GOTO |
	|	| 1  | 0  | $  |  S   |
	|-----------------------------|
	|   0   |    | s2 |    |  1   |
	|   1   |    |    | ac |      |
	|   2   | s3 | s2 |    |  4   |
	|   3   | r2 |    | r2 |      |
	|   4   | s5 |    |    |      |
	|   5   | r2 |    | r2 |      |
	-------------------------------


b)
	S'-> S
	S -> +SS | *SS | a
	a)
	I0: {S'-> .S, S -> .+SS, S -> .*SS, S -> .a}
	I1: {S' -> S.}
	I2: {S -> a.}
	I3: {S -> +.SS, S -> .+SS, S -> .*SS, S -> .a}
	I4: {S -> *.SS, S -> .+SS, S -> .*SS, S -> .a}
	I5: {S -> +S.S, S -> .+SS, S -> .*SS, S -> .a}
	I6: {S -> *S.S, S -> .+SS, S -> .*SS, S -> .a}
	I7: {S -> +SS.}
	I8: {S -> *SS.}

	GOTO(I0, S) = I1
	GOTO(I0, a) = I2
	GOTO(I0, +) = I3
	GOTO(I0, *) = I4

	GOTO(I3, S) = I5
	GOTO(I3, a) = I2
	GOTO(I3, +) = I3
	GOTO(I3, *) = I4

	GOTO(I4, S) = I6
	GOTO(I4, a) = I2
	GOTO(I4, +) = I3
	GOTO(I4, *) = I4

	GOTO(I5, S) = I7
	GOTO(I5, a) = I2
	GOTO(I5, +) = I3
	GOTO(I5, *) = I4

	GOTO(I6, S) = I8
	GOTO(I6, a) = I2
	GOTO(I6, +) = I3
	GOTO(I6, *) = I4

	b)
	No conflicts.
	c)
	(1) S -> +SS
	(2) S -> *SS
	(3) S -> a
	-----------------------------------
	| STATE |     ACTION	    | GOTO |
	|	| a  | +  | *  | $  |  S   |
	|----------------------------------|
	|   0   | s2 | s3 | s4 |    |  1   |
	|   1   |    |    |    | ac |      |
	|   2   | r3 | r3 | r3 | r3 |      |
	|   3   | s2 | s3 | s4 |    |  5   |
	|   4   | s2 | s3 | s4 |    |  6   |
	|   5   | s2 | s3 | s4 |    |  7   |
	|   6   | s2 | s3 | s4 |    |  8   |
	|   7   | r3 | r3 | r3 | r3 |      |
	|   8   | r3 | r3 | r3 | r3 |      |
	------------------------------------

c)
	S'-> S
	S -> S(S)S|e
	a)
	I0: {S'-> .S, S'-> S., S -> .S(S)S, S -> S.(S)S, S -> e}
	I1: {S -> S(.S)S ,S -> S(S.)S S -> .S(S)S, S -> S.(S)S, S -> e}
	I2: {S'-> S., S -> S.(S)S}
	I3: {S -> S(S.)S, S.(S)S}
	I4: {S -> S(S).S, S -> S(S)S., S -> .S(S)S, S -> S.(S)S, S -> e}
	I5: {S -> S(S)S., S -> S.(S)S}

	GOTO(I0, '(') = I1
	GOTO(I0, S) = I2

	GOTO(I1, ')') = I4
	GOTO(I1, S) = I3

	GOTO(I2, $) = accept
	GOTO(I2, '(') = I1

	GOTO(I3, '(') = I1
	GOTO(I3, ')') = I4

	GOTO(I4, '(') = I1
	GOTO(I4, 'S') = I5
	GOTO(I5, '(') = I1)

	b)
	No conflicts.
	c)
	(1) S -> S(S)S
	(2) S -> e
	-------------------------------
	| STATE |     ACTION   | GOTO |
	|	| (  | )  | $  |  S   |
	|-----------------------------|
	|   0   | s1 |    |    |  2   |
	|   1   |    | s4 |    |  3   |
	|   2   | s1 |    | ac |      |
	|   3   | s1 | s4 |    |      |
	|   4   | s1 | s4 |    |  5   |
	|   5   | s1 |    | r1 |      |
	-------------------------------
d)
	S'-> S
	S -> S+S|SS|(S)|S*|a
	a)
	I0: {S'-> .S, S -> .S+S, S -> .SS, S -> .(S), S -> .S*, S -> .a}
	I1: {S'-> S., S -> S.+S, S -> S.S, S -> S.*,
	              S -> .S+S, S -> .SS, S -> .(S), S -> .S*, S -> .a}
	I2: {S -> a.}
	I3: {S -> (.S),
	     S -> .S+S, S -> .SS, S -> .(S), S -> .S*, S -> .a}
	I4: {S -> S+.S,
	     S -> .S+S, S -> .SS, S -> .(S), S -> .S*, S -> .a}
	I5: {S*.}
	I6: {S -> SS.,
		S -> S.+S, S -> S.S, S -> S.*,
		S -> S -> .S+S, S -> .SS, S -> .(S), S -> .S*, S -> .a}
	I7: {S -> (S.),
	     S -> S.+S, S -> S.S, S -> S.*,
	     S -> .S+S, S -> .SS, S -> .(S), S -> .S*, S -> .a}
	I8: {S -> S+S.,
	     S -> S.+S, S -> S.S, S -> S.*,
	     S -> .S+S, S -> .SS, S -> .(S), S -> .S*, S -> .a}
	I9: {S -> (S).}
	GOTO(I0, S) = I1
	GOTO(I0, 'a') = I2
	GOTO(I0, '(') = I3

	GOTO(I1, 'a') = I2
	GOTO(I1, '(') = I3
	GOTO(I1, '*') = I5
	GOTO(I1, '+') = I4
	GOTO(I1, S) = I6
	GOTO(I1, $) = accept

	GOTO(I3, S) = I7
	GOTO(I3, '(') = I3
	GOTO(I3, 'a') = I2

	GOTO(I4, S) = I8
	GOTO(I4, '(') = I3
	GOTO(I4, 'a') = I2


	GOTO(I6, S) = I6
	GOTO(I6, '(') = I3
	GOTO(I6, 'a') = I2
	GOTO(I6, '*') = I5
	GOTO(I6, '+') = I4

	GOTO(I7, S) = I7
	GOTO(I7, ')') = I9
	GOTO(I7, '(') = I3
	GOTO(I7, 'a') = I2
	GOTO(I7, '*') = I5
	GOTO(I7, '+') = I4

	GOTO(I8, '(') = I3
	GOTO(I8, 'a') = I2
	GOTO(I8, '*') = I5
	GOTO(I8, S) = I8
	GOTO(I8, '+') = I4


	b)
	No conflict
	c)
	(1) S -> S+S
	(2) S -> SS
	(3) S -> (S)
	(4) S -> S*
	(5) S -> a
	-----------------------------------
	| STATE |     ACTION	              | GOTO |
	|	| a  | +  | *  | (  | )  | $  |  S   |
	|--------------------------------------------|
	|   0   | s2 |    |    | s3 |    |    |  1   |
	|   1   | s2 | s4 | s5 | s3 |    | ac |  6   |
	|   2   | r5 | r5 | r5 | r5 | r5 | r5 |      |
	|   3   | s2 |    |    | s3 |    |    |  7   |
	|   4   | s2 |    |    | s2 |    |    |  8   |
	|   5   | r4 | r4 | r4 | r4 | r4 | r4 |      |
	|   6   | s2 | s4 | s5 | s3 |    | r2 |  6   |
	|   7   | s2 | s4 | s5 | s3 | s9 |    |  7   |
	|   8   | s2 | s4 | s5 | s3 |    | r1 |      |
	|   9   |    |    |    |    |    | r3 |      |
	----------------------------------------------

e), f), g)
	Nope.

Exercise 4.6.5 : Show that the following grammar:
S -> A a A b | B b B a
A -> e
B -> e

	A LL(1) grammar ignores the epsilon symbols and parses the string as either
	ab or ba.

	FOLLOW(A) = FOLLOW(B) => reduce/reduce conflict

is LL(1) but not SLR( I ) .
Exercise 4.6.6 : Show that the following grammar:
S -> S A | A
A -> a
is SLR(1) but not LL(1):
	It is left recursive and therefore not parseable with LL(1), but since
	there is no shift reduce or reduce/reduce conflict it is parseable with
	SLR(1).
!! Exercise 4.6.7 : Consider the family of grammars Gn defined by:
S -> A.i b.i		for 1 <= i <= n
A.i -> a.j A.i | a.j	for 1 <= i, j <= n and i != j
Show that:
a) Gn has 2n^2 - n productions.
b) Gn has 2^n + n^2 + n sets of LR(O) items.
c) Gn is SLR(l ) .
What does this analysis say about how large L R parsers can get?
	Too ambiguous.

! Exercise 4.6.8 : We suggested that individual items could be regarded as
states of a nondeterministic finite automaton, while sets of valid items are the
states of a deterministic finite automaton (see the box on "Items as States of
an NFA" in Section 4.6.5) . For the grammar S -> SS+ | SS* | a of
Exercise 4.2.1:
a) Draw the transition diagram (NFA) for the valid items of this grammar
according to the rule given in the box cited above.
	See the dir.
b) Apply the subset construction (Algorithm 3.20) to your NFA from part (a).
How does the resulting DFA compare to the set of LR(O) items for
the grammar?
	Subset construction yields the following table:
	------------------------------------------------
	|  NFA states      | DFA states | a | + | * | S |
	|     {0,4,8}      |      A     | B |   |   | C |
	|       {3}        |      B     |   |   |   |   |
	|  {1,2,4,5,8,9}   |      C     | B |   |   | D |
	| {2,4,5,6,8,9,10} |      D     | B | E | F | D |
	|       {7}        |      E     |   |   |   |   |
	|       {11}       |      F     |   |   |   |   |
	-------------------------------------------------

	I0: {S'->.S, S -> SS+, S -> SS*, S -> .a}
	I1: {S -> a.}
	I2: {S' -> S., S -> S.S+, S -> S.S*, S -> SS+, S -> SS*, S -> .a}
	I3: {S -> SS.+, S -> SS.*, S -> S.S+, S -> S.S*, S -> SS+, S -> SS*, S -> .a}
	I4: {S -> SS+.}
	I5: {S -> SS*.}

	Equivalent.

!! c) Show that in all cases, the subset construction applied to the NFA that
comes from the valid items for a grammar produces the LR(O) sets of
items.
	Wordy:
	The algorithms for subset and item set construction are identical, but
	differ in the way they abstract the problem. Both algorithms make use
	of two functions: epsilon-closure and move, and CLOSURE and GOTO
	respectively. The two closure functions are equivalent: while epsilon-
	closure walks all edges labeled epsilon and adds them to the DFA state,
	CLOSURE does the same thing implicitly -- by expanding all nonterminals
	accessible from the current item recursively and adds them to the item
	set. With respect to the other two functions move and GOTO, they do
	however differ. In item set construction GOTO(X, a) makes a transition
	on the symbol a in all items whose next symbol is a. It then computes
	CLOSURE on all the new items it accessed. In the subset construction
	move(X, a) walks the edges labeled a from each NFA state in X adds them
	to the DFA state. The algorithm then computes epsilon-closure on the
	resulting states. Hence, the difference between the algorithms is that
	subset construction computes the epsilon-closure explicitly at every
	iteration of the algorithm, while item set construction computes it
	implicitly.
	Not wordy:
	CLOSURE <=> epsilon-closure
	GOTO <=> epsilon-closure(move)

! Exercise 4.6.9 : The following is an ambiguous grammar:
		S -> A S | b
		A -> S A | a
Construct for this grammar its collection of sets of LR(O) items. If we try to
build an LR-parsing table for the grammar, there are certain conflicting actions.
What are they? Suppose we tried to use the parsing table by nondeterminis­tically
choosing a possible action whenever there is a conflict. Show all the possible
actions on input abab.

	S'-> S
	S -> A S
	S -> b
	A -> S A
	A -> a

	I0: {S'-> .S, S -> .A S, A -> .S A, A -> .a, S -> .b}
	I1: {A -> a.}
	I2: {S -> b.}
	I3: {S'-> S., A -> S.A, A ->.S A, A -> .a, S -> .b}
	I4: {S -> A.S, S ->.A S, A -> .a, S -> .b}
	I5: {A -> S.A, A ->.S A, A -> .a, S -> .b}
	I6: {A -> SA.}
	I7: {S -> AS,}
	I8: {S -> A.S, S -> .AS, A -> .a, S -> .b}

	There is a shift/reduce conflict in that several of the item sets
	resolve both directly to a terminal and via a nonterminal


	S' => S => A S => A A S >= A A b => A S A b => A S ab => A bab => abab
		       => A b => S A b => S ab => A S ab => A bab => abab
