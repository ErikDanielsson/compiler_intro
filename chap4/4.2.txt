Exercise 4.2.1 : Consider the context-free grammar:
	S -> SS+ | SS* | a
and the string aa + a*.
a) Give a leftmost derivation for the string.
	S => SS* => SS+S* => aS+S* => aa+S* => aa+a*

b) Give a rightmost derivation for the string.
	S => SS* => Sa* => SS+a* => Sa+a* => aa+a*

c) Give a parse tree for the string.
	    	    S
		  / | \
	         /  |  \
	        S   S   \
	      / | \  \   |
             S  S  |  |  |
	     |  |  |  |  |
	     a  a  +  a  *

! d) Is the grammar ambiguous or unambiguous? Justify your answer.
	Unambiguous. Since the operator is at the end of the production, there
	is only	one way for the parse tree to be constructed. Compared to the
	case in the Dragon book where the expression id + id * id was determined
	to be ambiguous because	the middle operand could be associated with
	either operator, in an expression of the above grammar there is no
	ambiguity in  what operator the operands are associated with.

! e) Describe the language generated by this grammar.
	Postfix notation
Exercise 4.2.2 : Repeat Exercise 4.2.1 for each of the following grammars and
strings:

1) S -> 0S1 | 01 with string 000111.
	a)
	S => 0S1 => 00S11 => 000111
	b)
	S => 0S1 => 00S11 => 000111
	c)

		S
	      / | \
	     /	S  \
	    / / | \ \
	   / /  S  \ \
	   | | | | | |
	   0 0 0 1 1 1
	d)
	Unambiguous. Since there is no branching, there can be no ambiguity.
	e)
	L  = {O^n1^n | n > 0}
2) S -> +SS|*SS|a with string +*aaa.
	a)
	S => +SS => +*SSS => +*aSS => +*aaS => +*aaa
	b)
	S => +SS => +Sa => +*SSa => +*Saa => +*aaa
	c)
	          S
		/ | \
	       /  |  \
	      /   S   S
	     /  / | \  \
	    /  /  S  S  S
	    |  |  |  |  |
	    +  *  a  a  a
	d)
	Unambiguous. Same explanation as 4.2.1 d).
	e)
	Prefix notation.

3) S -> S(S)S | epsilon with string (()()).
	a)
	S => S(S)S => (S)S => (S(S)S)S => ((S)S)S => (()S)S =>
	(()S(S)S)S => (()(S)S)S => (()()S)S => (()())S => (()())
	b)
	S => S(S)S => S(S) => S(S(S)S) => S(S(S)) => S(S()) =>
	S(S(S)S()) => S(S(S)()) => S(S()()) => S(()()) => (()())
	c) (e := epsilon)
	        -- S --
	       / / | \ \
	      / /  |  \ \
	     / /   |   \ \
	    / /    |    \ \
	   S /  -- S --  \ S
	   | | / / | \  \ \ \
           e | S | S  |  \ \ \
 	     | | | |  |   \ \ \
	     | | | |  |    \ \ \
	     | | | |  |     \ \ \
	     | | | |  |     |  \ \
	     | e | e  |     |   \ \
             |   |    |  -- S -- \ \
	     |   |    | / / | \ \ \ \
             |   |    | S | S |  S | |
	     |   |    | | | | |  | | |
	     |   |    | e | e |  e | e
	     (   (    )   (   )    )
	d)
	Ambiguous. For example a) could additionally be done in this way:
	S => S(S)S => (S)S => (S(S)S)S => (S(S)S(S)S)S => ((S)S(S)S)S =>
	S => (()S(S)S)S => (()(S)S)S => (()()S)S => (()())S => (()())
	e)
	All configurations of matching parenthesis

4) S+S|SS|(S)|S*|a with string (a+a)*a.
	a)
	S => SS => S*S => (S)*S => (S+S)*S => (a+S)*S => (a+a)*S => (a+a)*a
	b)
	S => SS => Sa => S*a => (S)*a => (S+S)*a => (S+a)*a => (a+a)*a
	c)
	 	S
	       / \
              S   S
	     / \   \
	    S   *   a
          / | \
         (  S  )
	  / | \
	 S  +  S
	 |     |
	 a     a


	d) Unambiguous. Since all productions operate on the string in different
	ways.
	e)
	Someone said regexes. I don't know vette fan.
5) S -> (L)|a and L -> L,S|S with string ((a,a)a,(a)).
	a)
	S => (L) => (L,S) => (L,S,S) => (S,S,S) => ((L),S,S) =>
	((L,S),S,S) => ((S,S),S,S) => ((a,S),S,S) =>
	((a,a),S,S) => ((a,a),a,(L)) => ((a,a),a,(S)) =>
	((a,a),a,(a))
	b)
	S => (L) => (L,S) => (L,(L)) => (L,(S)) => (L,(a)) => (L,S,(a)) =>
	(L,a,(a)) => (S,a,(a)) => ((L),a,(a)) => ((L,S),a,(a)) =>
	((L,a),a,(a)) => ((S,a),a,(a)) => ((a,a),a,(a))
	c)
	                 S
	               / | \
                      (  L  )
		       / | \
                      L  ,  S
		    / | \    \
		   L  ,  S    \
		  /      |     \
		 S       a   / | \
	       / | \        (  L  )
	      (  L  )          |
	       / | \           S
	      L  ,  S          |
	      |     |          a
              S     a
	      |
	      a

	d) Unambiguous. Since there is only one branching case.
	e) Nested lists of 'a's
6) S -> aSbS|bSaS|epsilon with string aabbab
	a)
	S => aSbS => aaSbSbS => aabSbS => aabbSabS => aabbabS => aabbab
	b)
	S => aSbS => aSb => aaSbSb => aaSbbaSb => aaSbbab => aabbab
	c)
	       - S -
	      / / \ \
             a /   b \
	    - S -     S
           / / \ \     \
          a S   b S     e

	d) Ambiguous. The above string could also be constructed in this manner:
	S => aSbS => aaSbSbS => aabSbS => aabbS => aabbaSbS => aabbabS => aabbab
	e) All strings with the same number of 'a's as 'b's
7) bexpr -> bexpr or bterm | bterm
   bterm -> bterm and bfactor | bfactor
   bfactor -> not bfactor | (bexpr) | true | false
   	a), b), c) No expression provided
	d) Unambiguous. Since precedence is accounted for by the several
	productions, there is no way to construct two trees from an expression
	e) boolean expressions terminating in 'true' or 'false'.


Exercise 4.2.3 : Design grammars for the following languages:
a) The set of all strings of 0s and I s such that every 0 is immediately
followed by at least one 1.
	S -> S01|S1

! b) The set of all strings of 0s and I s that are palindromes; that is, the string
reads the same backward as forward.
	S -> 0S0|1S1|0|1|epsilon

! c) The set of all strings of 0s and Is with an equal number of 0s and 1s.
	S -> 01S|10S|epsilon

!! d ) The set of all strings of 0s and 1s with an unequal number of 0s and 1s.
	S -> 01S|10S|1|0

! e) The set of all strings of 0s and 1s in which 011 does not appear as a
substring.
	S -> 1S|L
	L -> 0L|10L|epsilon

!! f) The set of all strings of Os and 1s of the form xy, where x != y and x and
y are of the same length.
	S -> 0S1|1S0|1S1|0S0|L
	L -> 0S1|1S0|epsilon

! Exercise 4.2.4 : There is an extended grammar notation in common use. In
this notation, square and curly braces in production bodies are metasymbols
(like -> or |) with the following meanings:

i) Square braces around a grammar symbol or symbols denotes that these
constructs are optional. Thus, production A -> X [Y] Z has the same effect as
the two productions A -> X Y Z and A -> X Z.

ii) Curly braces around a grammar symbol or symbols says that these sym­bols may
be repeated any number of times, including zero times. Thus,A -> X {Y Z} has
the same effect as the infinite sequence of productions A -> X , A -> X Y Z,
A -> X Y Z Y Z, and so on.

Show that these two extensions do not add power to grammars; that is, any
language that can be generated by a grammar with these extensions can be
generated by a grammar without the extensions.
	A -> X [Y] Z <=> A -> X Y | X Y Z
	A -> X {Y} <=> A -> X B, B -> Y B | epsilon

Exercise 4.2.5 : Use the braces described in Exercise 4.2.4 to simplify the
following grammar for statement blocks and conditional statements:
stmt -> if expr then stmt else stmt
      | if expr then stmt
      | begin stmtList end
stmtList -> stmt; stmtList | stmt

	stmt -> if expr then stmt [else stmt]
	      | begin {stmt;} stmt end

! Exercise 4.2.6 : Extend the idea of Exercise 4.2.4 to allow any regular
expression of grammar symbols in the body of a production. Show that this
extension does not allow grammars to define any new languages.
	Concatenation:
	A -> XY

	Alternation:
	A -> X|Y <=> A -> X
		     A -> Y

	Kleene closure:
	A -> X {Y} <=> A -> X B, B -> Y B | epsilon

! Exercise 4.2.7 : A grammar symbol X (terminal or nonterminal) is useless if
there is no derivation of the form S =*> wXy =*> wxy. That is, X can never
appear in the derivation of any sentence.
a ) Give an algorithm to eliminate from a grammar all productions containing
useless symbols.
	INPUT: A grammar G, of an alphabet L not containing epsilon
	OUTPUT: A not useless grammar NUG
	METHOD:
	set<grammar symbol> table= empty;
	function visit(production p):
		if p  in table:
		   return;
		table.insert(p)
		if p.body does not contain any symbol of L:
			if p is nonterminal:
				for grammar_symbol s in p.body:
					visit(s)
				for  grammar_symbol s in p.body
					if s.body is terminal:
						replace s with s.body
				if p.body only contains p:
					remove p
			else:
				// p.body is epsilon
				remove p
		else:
			for grammar_symbol S in p.body:
				visit_production(S)
			return
b ) Apply your algorithm to the grammar:
	S -> 0|A
	A -> AB
	B -> 1

	S -> 0|A
	A -> A1

	Exercise 4.2.8 : The grammar in Fig. 4.7 generates declarations for a
	sin­gle numerical identifier; these declarations involve four different,
	independent properties of numbers.

			stmt -> declare id optionList
			optionList -> optionList option | epsilon
			option -> mode | scale | precision | base
			mode -> real | complex
			scale -> fixed | floating
			precision -> single | double
			base -> binary | decimal

		Figure 4.7: A grammar for multi-attribute declarations.

	a) Generalize the grammar of Fig. 4.7 by allowing n options Ai, for some
	fixed n and for i = 1, 2..., n, where Ai can be either ai or bi· Your
	grammar should use only O(n) grammar symbols and have a total length
	of productions that is O(n)

	Indecipherable... what is ai and bi?

	! b) The grammar of Fig. 4.7 and its generalization in part (a) allow
	declarations that are contradictory and/or redundant, such as:

			declare foo real fixed real floating

	We could insist that the syntax of the language forbid such declarations;
	that is, every declaration generated by the grammar has exactly one
	value for each of the n options. If we do, then for any fixed n there is
	only a finite number of legal declarations. The language of legal
	declarations thus has a grammar (and also a regular expression),
	as any finite language does.The obvious grammar, in which the start
	symbol has a production for every legal declaration has n! productions
	and a total production length of O(n*n!). You must do better: a total
	production length that is O(n*2^n).

	Naive approach: Explicit declaration of every permutation, which results
	in O(n!) symbols.
	Nicer approch, "grammars can count to two":
	The grammar can be configured as a binary tree in this fashion:

		S0 -> S1 S2 | S2 S1
		S1 -> S11 S12 | S12 S11
		S2 -> S21 S22 | S22 S21
		...
		S(1{n}) -> a1
		...

	For n = 6 the productions would point in the following way:

			S0
		       /  \
		     S1    S2
		    /  \   |  \
		 S11   S12 |   |
		 / \   / \ \   |
		a1 a2 a3 a4 a5 a6

	Since there is a binary decision for the orientation of the nodes leaves
	all possibilities for the options are possible.

	!! c) Show that any grammar for part (b) must have a total production length
	of at least 2^n.
	I don't know, doesn't the binary tree make it linear?
	d ) What does part ( c ) say about the feasibility of enforcing nonredundancy
	and noncontradiction among options in declarations via the syntax of the
	programming language?
	It is feasible for small cases, but not for big ones -- I guess.
