Exercise 4.2.1 : Consider the context-free grammar:
	S -> SS+ | SS* | a
and the string aa + a*.
a) Give a leftmost derivation for the string.
	S => SS* => SS+S* => aS+S* => aa+S* => aa+a*

b) Give a rightmost derivation for the string.
	S => SS* => Sa* => SS+a* => Sa+a* => aa+a*

c) Give a parse tree for the string.
	    	    S
		  / | \
	         /  |  \
	        S   S   \
	      / | \  \   |
             S  S  |  |  |
	     |  |  |  |  |
	     a  a  +  a  *

! d) Is the grammar ambiguous or unambiguous? Justify your answer.
	Unambiguous. Since the operator is at the end of the production, there
	is only	one way for the parse tree to be constructed. Compared to the
	case in the Dragon book where the expression id + id * id was determined
	to be ambiguous because	the middle operand could be associated with
	either operator, in an expression of the above grammar there is no
	ambiguity in  what operator the operands are associated with.

! e) Describe the language generated by this grammar.
	Postfix notation
Exercise 4.2.2 : Repeat Exercise 4.2.1 for each of the following grammars and
strings:

1) S -> 0S1 | 01 with string 000111.
	a)
	S => 0S1 => 00S11 => 000111
	b)
	S => 0S1 => 00S11 => 000111
	c)

		S
	      / | \
	     /	S  \
	    / / | \ \
	   / /  S  \ \
	   | | | | | |
	   0 0 0 1 1 1
	d)
	Unambiguous. Since there is no branching, there can be no ambiguity.
	e)
	L  = {O^n1^n | n > 0}
2) S -> +SS|*SS|a with string +*aaa.
	a)
	S => +SS => +*SSS => +*aSS => +*aaS => +*aaa
	b)
	S => +SS => +Sa => +*SSa => +*Saa => +*aaa
	c)
	          S
		/ | \
	       /  |  \
	      /   S   S
	     /  / | \  \
	    /  /  S  S  S
	    |  |  |  |  |
	    +  *  a  a  a
	d)
	Unambiguous. Same explanation as 4.2.1 d).
	e)
	Prefix notation.

3) S -> S(S)S | epsilon with string (()()).
	a)
	S => S(S)S => (S)S => (S(S)S)S => ((S)S)S => (()S)S =>
	(()S(S)S)S => (()(S)S)S => (()()S)S => (()())S => (()())
	b)
	S => S(S)S => S(S) => S(S(S)S) => S(S(S)) => S(S()) =>
	S(S(S)S()) => S(S(S)()) => S(S()()) => S(()()) => (()())
	c) (e := epsilon)
	        -- S --
	       / / | \ \
	      / /  |  \ \
	     / /   |   \ \
	    / /    |    \ \
	   S /  -- S --  \ S
	   | | / / | \  \ \ \
           e | S | S  |  \ \ \
 	     | | | |  |   \ \ \
	     | | | |  |    \ \ \
	     | | | |  |     \ \ \
	     | | | |  |     |  \ \
	     | e | e  |     |   \ \
             |   |    |  -- S -- \ \
	     |   |    | / / | \ \ \ \
             |   |    | S | S |  S | |
	     |   |    | | | | |  | | |
	     |   |    | e | e |  e | e
	     (   (    )   (   )    )
	d)
	Ambiguous. For example a) could additionally be done in this way:
	S => S(S)S => (S)S => (S(S)S)S => (S(S)S(S)S)S => ((S)S(S)S)S =>
	S => (()S(S)S)S => (()(S)S)S => (()()S)S => (()())S => (()())
	e)
	All configurations of matching parenthesis

4) S+S|SS|(S)|S*|a with string (a+a)*a.
	a)
	S => SS => S*S => (S)*S => (S+S)*S => (a+S)*S => (a+a)*S => (a+a)*a
	b)
	S => SS => Sa => S*a => (S)*a => (S+S)*a => (S+a)*a => (a+a)*a
	c)
	 	S
	       / \
              S   S
	     / \   \
	    S   *   a
          / | \
         (  S  )
	  / | \
	 S  +  S
	 |     |
	 a     a


	d) Unambiguous. Since all productions operate on the string in different
	ways.
	e)
	Someone said regexes. I don't know vette fan.
5) S -> (L)|a and L -> L,S|S with string ((a,a)a,(a)).
	a)
	S => (L) => (L,S) => (L,S,S) => (S,S,S) => ((L),S,S) =>
	((L,S),S,S) => ((S,S),S,S) => ((a,S),S,S) =>
	((a,a),S,S) => ((a,a),a,(L)) => ((a,a),a,(S)) =>
	((a,a),a,(a))
	b)
	S => (L) => (L,S) => (L,(L)) => (L,(S)) => (L,(a)) => (L,S,(a)) =>
	(L,a,(a)) => (S,a,(a)) => ((L),a,(a)) => ((L,S),a,(a)) =>
	((L,a),a,(a)) => ((S,a),a,(a)) => ((a,a),a,(a))
	c)
	                 S
	               / | \
                      (  L  )
		       / | \
                      L  ,  S
		    / | \    \
		   L  ,  S    \
		  /      |     \
		 S       a   / | \
	       / | \        (  L  )
	      (  L  )          |
	       / | \           S
	      L  ,  S          |
	      |     |          a
              S     a
	      |
	      a

	d) Unambiguous. Since there is only one branching case.
	e) Nested lists of 'a's
6) S -> aSbS|bSaS|epsilon with string aabbab
	a)
	S => aSbS => aaSbSbS => aabSbS => aabbSabS => aabbabS => aabbab
	b)
	S => aSbS => aSb => aaSbSb => aaSbbaSb => aaSbbab => aabbab
	c)
	       - S -
	      / / \ \
             a /   b \
	    - S -     S
           / / \ \     \
          a S   b S     e
           
